<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Liquid1</name></assembly>
<members>
<member name="P:Microsoft.Research.Liquid.Complex.Tol(System.Double)">
 <summary>
 Tolerance for comparing two Complex numbers.
 This is used in various places in the system.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_UnaryNegation(Microsoft.Research.Liquid.Complex)">
 <summary>
 Gets the negation of a Complex number.
 </summary>
 <param name="a">The Complex number to negate</param>
 <returns>The negated Complex number, (-r,-i)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_TwiddleTwiddle(Microsoft.Research.Liquid.Complex)">
 <summary>
 Gets the complex conjugate of a Complex number.
 </summary>
 <param name="a">The Complex number to conjugate.</param>
 <returns>The conjugated Complex number</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_Subtraction(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
 <summary>
 Subtracts one Complex number from another.
 </summary>
 <param name="a">The left-hand operand</param>
 <param name="b">The right-hand operand</param>
 <returns>The difference of the two operands</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_Multiply(Microsoft.Research.Liquid.Complex,System.Double)">
 <summary>
 Multiplies a Complex and a real number.
 </summary>
 <param name="a">The Complex number</param>
 <param name="b">The real number</param>
 <returns>The product of the two numbers</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_Multiply(System.Double,Microsoft.Research.Liquid.Complex)">
 <summary>
 Multiplies a real and a Complex number.
 </summary>
 <param name="a">The real number</param>
 <param name="b">The Complex number</param>
 <returns>The product of the two numbers</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_Multiply(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
 <summary>
 Multiplies two Complex numbers.
 </summary>
 <param name="a">Left hand operand.</param>
 <param name="b">Right hand operand.</param>
 <returns>The product of the two numbers</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.op_Addition(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
 <summary>
 Adds two Complex numbers.
 </summary>
 <param name="a">The left-hand operand</param>
 <param name="b">The right-hand operand</param>
 <returns>NThe sum of the two operands</returns>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.r">
 <summary>
 Gets the real part of this Complex number.
 </summary>
 <value>The real part</value>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.i">
 <summary>
 Gets the imaginary part of this Complex number.
 </summary>
 <value>The imaginary part</value>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.Zero">
 <summary>
 Zero, as a Complex number
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.Tol">
 <summary>
 Tolerance for comparing two Complex numbers.
 This is used in various places in the system.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.One">
 <summary>
 One, as a Complex number
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.MCC">
 <summary>
 Gets the squared magnitude of this Complex number.
 </summary>
 <returns>The squared magnitude (r*r+i*i)</returns>
</member>
<member name="P:Microsoft.Research.Liquid.Complex.I">
 <summary>
 The square root of negative one, as a Complex number.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.Wide">
 <summary>
 Converts this Complex number to a string suitable for input to other programs.
 </summary>
 <returns>The formatted string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.ToString">
 <summary>
 Converts this Complex number to a human-readable string.
 </summary>
 <returns>The formatted string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.Narrow">
 <summary>
 Converts this Complex number to a short human-readable string.
 </summary>
 <returns>The formatted string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this Complex number to the console and log with an optional indentation.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.Copy">
 <summary>
 Duplicates this Complex number in a new instance.
 </summary>
 <returns>The new Complex</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.Conj">
 <summary>
 Computes the complex conjugate of this Complex number.
 </summary>
 <returns>The conjugate</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Complex.#ctor(System.Double,System.Double)">
 <summary>
 Constructs a complex number from its real and imaginary parts.
 </summary>
 <param name="r">Real value</param>
 <param name="i">Imaginary value</param>
</member>
<member name="T:Microsoft.Research.Liquid.Complex">
 <summary>Data type for complex numbers.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.r(System.Int32,System.Int32,System.Double)">
 <summary>
 Real set by dense index (if it WAS 0, you need to call FixManual when done)
 </summary>
 <param name="x">row</param>
 <param name="y">col</param>
 <param name="v">Real value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.r(System.Int32,System.Double)">
 <summary>
 Real set by sparse index
 </summary>
 <param name="j">Sparse index</param>
 <param name="v">Real value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.i(System.Int32,System.Int32,System.Double)">
 <summary>
 Imaginary set by dense index (if it WAS 0, you need to call FixManual when done)
 </summary>
 <param name="x">row</param>
 <param name="y">col</param>
 <param name="v">Imaginary value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.i(System.Int32,System.Double)">
 <summary>
 Imaginary set by sparse index
 </summary>
 <param name="j">Sparse index</param>
 <param name="v">imaginary value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Item(System.Int32,System.Int32,Microsoft.Research.Liquid.Complex)">
 <summary>
 Sets an element of the matrix.
 </summary>
 <param name="x">The row index of the element to set.</param>
 <param name="y">The column index of the element to set.</param>
 <param name="v">The Complex value to set the element to</param>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Item(System.Int32,Microsoft.Research.Liquid.Complex)">
 <summary>
 Element set by sparse index
 </summary>
 <param name="j">Sparse index</param>
 <param name="v">Complex value to set</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.op_MultiplyBang(Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CSMat)">
 <summary>
 Computes the Kronecker product of two matrices
 </summary>
 <param name="m1">The left matrix</param>
 <param name="m2">The right matrix</param>
 <returns>The result of the Kronecker product</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.op_Multiply(Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CSMat)">
 <summary>
 Computes the product of two matrices.
 Highly efficient.
 </summary>
 <param name="m1">The left-hand matrix.</param>
 <param name="m2">THe right-hand matrix.</param>
 <returns>The resulting product matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.op_Multiply(Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CVec)">
 <summary>
 Computes the product of a matrix and a vector.
 </summary>
 <param name="m">The matrix</param>
 <param name="v">The vector</param>
 <returns>The resulting vector</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.r(System.Int32,System.Int32)">
 <summary>
 Real access by dense index
 </summary>
 <param name="x">Row</param>
 <param name="y">Col</param>
 <returns>Real value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.r(System.Int32)">
 <summary>
 Real access by sparse index
 </summary>
 <param name="j">Sparse index</param>
 <returns>real value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.i(System.Int32,System.Int32)">
 <summary>
 Imaginary access by dense index
 </summary>
 <param name="x">Row</param>
 <param name="y">Col</param>
 <returns>imaginary value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.i(System.Int32)">
 <summary>
 Imaginary access by sparse index
 </summary>
 <param name="j">Sparse index</param>
 <returns>imaginary value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Ys">
<summary>
 For fast bulk access
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Xs">
<summary>
 For fast bulk access (remember to call FixManual() if you write to this array)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Rs">
<summary>
 For fast bulk access
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Length">
 <summary>
 The dimension of this matrix; that is, the number of rows or columns.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Item(System.Int32,System.Int32)">
 <summary>
 Gets an element of the matrix.
 </summary>
 <param name="x">The row index of the desired element.</param>
 <param name="y">The column index of the desired element.</param>
 <returns>The matrix element, as a Complex number</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Item(System.Int32)">
 <summary>
 Element access by sparse index
 </summary>
 <param name="j">Sparse index</param>
 <returns>Complex value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Is">
<summary>
 For fast bulk access
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CSMat.Count">
<summary>
 Count of sparse entries
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Write(System.IO.BinaryWriter)">
 <summary>
 Writes this matrix to a stream.
 The matrix may be recreated by using the 
 <see cref="M:Microsoft.Research.Liquid.CSMat.Read(System.IO.BinaryReader)">Read</see> method.
 </summary>
 <param name="bw">The stream to serialize this matrix to</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.UnitaryError">
 <summary>
 Performs a rough check to see if this matrix is actually unitary.
 It calculates the biggest deviation from 1 of the diagonal elements
 of (this adj)*this.
 In other words, it calculates the largest deviation of the length of a row,
 viewed as a complex vector, from 1.
 The orthogonality of different rows is not checked.
 </summary>
 <returns>The worst deviation from 1.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.ToString">
 <summary>
 Gets a string representation of this matrix.
 Note that all non-zero elements are listed, so this string may be quite long.
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.ToDense">
 <summary>
 Create a dense matrix from a sparse one
 </summary>
 <returns>New dense complex matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.SparseO(System.Int32,System.Int32)">
 <summary>
 Get a sparse index from a dense one (only if it really exists already)
 </summary>
 <param name="x">row</param>
 <param name="y">col</param>
 <returns>Some index or None</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Sparse(System.Int32,System.Int32)">
 <summary>
 Get a sparse index from a dense one (create if it doesn't exist)
 Remember to call FixManual() if you create new ones
 </summary>
 <param name="x">row</param>
 <param name="y">col</param>
 <returns>sparse index</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Read(System.IO.BinaryReader)">
 <summary>
 Reads a matrix from a stream.
 The matrix must originally have been written using the 
 <see cref="M:Microsoft.Research.Liquid.CSMat.Write(System.IO.BinaryWriter)">Write</see> method.
 </summary>
 <param name="br">The stream to read the data from.</param>
 <returns>The read-in matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.MulPrep(Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.MulPrepT})">
 <summary>
 Prep for in-place partial repeated multiply
 </summary>
 <param name="mpShared">Optional shared dictionary</param>
 <returns>structure for partial multiply routine</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Mul(Microsoft.Research.Liquid.CSMat)">
 <summary>
 Computes the product of this matrix and another matrix.
 Highly efficient.
 </summary>
 <param name="m2">The right-hand matrix to be multiplied by this matrix.</param>
 <returns>New resulting sparse matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Mul(Microsoft.Research.Liquid.CSMat,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Int32,System.Int32,System.Int32}}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32,System.Int32},System.Boolean}})">
 <summary>
 Matrix * Matrix (Matrix MUST be in correct sorted order (FixManual() if necessary)
 Highly efficient.
 </summary>
 <param name="m2">Right hand matrix</param>
 <param name="legalRow">Optional routine for decimating rows (see GrowSingle)</param>
 <param name="legalCol">Optional routine for decimating cols (see GrowSingle)</param>
 <returns>New resulting sparse matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Mul(Microsoft.Research.Liquid.CVec,System.UInt64,Microsoft.Research.Liquid.MulPrepT)">
 <summary>
 M*V In place partial multiply (block diagonal repeated matrix)
 </summary>
 <param name="v">Vector to multiply</param>
 <param name="offset">Place to start in vector</param>
 <param name="mp">prepared parameters</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Mul(Microsoft.Research.Liquid.CVec)">
 <summary>
 Computes the product of this matric and a vector.
 </summary>
 <param name="v">The vector to multiply.</param>
 <returns>The resulting vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Kron(System.Int32)">
 <summary>
 Computes the Kronecker Product of this matrix with an identity matrix.
 The identity matrix is on the right-hand side of the product.
 </summary>
 <param name="lenI">The dimension of the identity matrix (N of NxN).</param>
 <returns>The result of the Kronecker product</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Kron(Microsoft.Research.Liquid.CSMat)">
 <summary>
 Computes the Kronecker Product of this matrix with another matrix.
 </summary>
 <param name="m2">The right-hand side matrix in the Kronecker product.</param>
 <returns>The result of the Kronecker product</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.FixManual(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Fix manual updates (compress zeros and sort rows)
 This *MUST* be called after moving any rows entries (xs)
 </summary>
 <param name="fullSort">Sort columns as well? (optional=false)</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.FindXIndex(System.Int32)">
 <summary>
 Binary search sorted row indices for first one before the argument
 </summary>
 <param name="x">Row index to search for</param>
 <returns>Sparse index or 0 if we can't find it</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Filled">
 <summary>
 Return indicies of filled entries in the sparse matrix (may include zeros)
 </summary>
 <returns>Sequence of x,y tuples to access matrix with</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Expand(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
 <summary>
 Build an operator to work on more bits mapping items to new index.
 This builds new expanded Unitary operators in new orders in one call.
 </summary>
 <param name="map">Map of bit positions to operate on</param>
 <returns>New sparse matrix result</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Equals(Microsoft.Research.Liquid.CSMat,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>
 Determines whether this matrix is equal to another.
 </summary>
 <param name="m2">The sparse matrix to compare to.</param>
 <param name="tol">An optional tolerance for considering real or imaginary parts equal.
 The default is Complex.Tol.</param>
 <returns>true if the matrices are equal, within the tolerance limit, or 
 false otherwise.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.DumpML(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this matrix in MatLab format.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="nam">An optional name for the matrix. The default is A.</param>   
 <param name="idxOffset">An optional number of rows and columns to skip.
 If this is not zero, then the square submatrix starting at this offset is dumped instead of the full matrix.
 The default is 0.</param>   
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.DumpMCC(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this matrix as a list of row-column indices and element squared magnitudes.
 Note that all non-zero elements are listed, so the output may be quite long.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.DumpDense(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this sparse matrix in the same format as a dense matrix.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this matrix as a list of row-column indices and element complex values.
 Note that all non-zero elements are listed, so the output may be quite long.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Dense(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a dense matrix from this sparse matrix.
 </summary>
 <param name="zeros">Option to create a dense matrix the same size as this matrix
 but filled with zeroes, rather than copying this matrix. The default is to copy
 the entries of this matrix to the new dense matrix.</param>
 <returns>The new dense matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Copy">
 <summary>
 Makes a copy of this matrix.
 </summary>
 <returns>The new matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Clear">
 <summary>
 Clears out this matrix, setting all elements to zero.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.CheckGood(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Check if matrix is in legal ordering (FixManual needed)?
 </summary>
 <param name="fullSort">Sort columns as well? (optional=false)</param>
 <returns>zeros,needSort (bools)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.Adj">
 <summary>
 Computes the adjoint (complex conjugate transpose) of this matrix.
 </summary>
 <returns>A new matrix that is the adjoint of this matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.#ctor(Microsoft.Research.Liquid.CMat,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>
 Creates a sparse matrix from a dense matrix.
 </summary>
 <param name="m">The source matrix.</param>
 <param name="tol">An optional tolerance for identifying zero elements.
 The default is to use Complex.tol as the maximum magnitude to consider 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.#ctor(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double,System.Double}})">
 <summary>
 Creates a matrix from a list of elements.
 </summary>
 <param name="len">The dimension of the matrix; that is, the row or column count.</param>
 <param name="xyris">A list of elements. Each element should be a tuple in the form (row,col,real,imag).</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a new square identity or zero matrix.
 </summary>
 <param name="n">The dimension of the matrix; that is, the row or column count.</param>
 <param name="zero">An option to create a zero matrix rather than an identity matrix, if true.
 The default is false, which creates an identity matrix.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CSMat.#ctor(System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a new square matrix.
 </summary>
 <param name="_len">The dimension of the matrix; that is, the row or column count.</param>
 <param name="_xs">An array of Row indices</param>
 <param name="_ys">Col indices</param>
 <param name="_rs">Real values</param>
 <param name="_is">Imaginary values</param>
 <param name="dontFix">Dont perform fixup? [USE WITH CARE] (optional=false)</param>
</member>
<member name="T:Microsoft.Research.Liquid.CSMat">
 <summary>
 A sparse matrix of complex numbers.
 <seealso cref="T::Microsoft.Research.Liquid.CMat"/>
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.MulPrepT">
 <summary>
 Used for fast blocked multiply (see CSMat.MulPrep method)
 <ul>
 <li>vRI: Vector of Reals and Imaginaries (interleaved) </li>
 <li>xyris: filled in rows and columns</li>
 </ul>
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.r(System.Int32,System.Int32,System.Double)">
 <summary>
 Set a real
 </summary>
 <param name="i">Row</param>
 <param name="j">Column</param>
 <param name="v">real</param>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.i(System.Int32,System.Int32,System.Double)">
 <summary>
 Set imaginary
 </summary>
 <param name="i">Row</param>
 <param name="j">Column</param>
 <param name="v">imaginary</param>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.Item(System.Int32,System.Int32,Microsoft.Research.Liquid.Complex)">
 <summary>
 Sets an individual element of the matrix from a Complex number.
 </summary>
 <param name="i">The row index.</param>
 <param name="j">The column index.</param>
 <param name="v">The Complex value to store in the matrix element.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.op_MultiplyBang(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CMat)">
 <summary>
 Computes the Kronecker product of two matrices
 </summary>
 <param name="m1">The left matrix</param>
 <param name="m2">The right matrix</param>
 <returns>The result of the Kronecker product</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.op_MultiplyAssignment(Microsoft.Research.Liquid.CMat,System.Double)">
 <summary>
 Scales a matrix by a constant multiplier.
 The matrix is updated in place, rather than a new matrix being created.
 </summary>
 <param name="m1">The matrix to scale.</param>
 <param name="mul">The constant to multiply by.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.op_Multiply(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CMat)">
 <summary>
 Computes the product of two matrices.
 The first matrix must have the same number of columns as the second matrix has rows.
 </summary>
 <param name="m1">The left (first) matrix</param>
 <param name="m2">The right (second) matrix</param>
 <returns>The resulting product matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.op_Multiply(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CVec)">
 <summary>
 Computes the product of a matrix and a vector.
 The vector's length must match the numder of columns in the matrix.
 </summary>
 <param name="m">The matrix</param>
 <param name="v">The vector</param>
 <returns>The resulting product vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.op_DivisionAssignment(Microsoft.Research.Liquid.CMat,System.Double)">
 <summary>
 Scales a matrix by a constant divisor.
 The matrix is updated in place, rather than a new matrix being created.
 </summary>
 <param name="m1">The matrix to scale.</param>
 <param name="div">The scale divisor. The matrix is multiplied by 1/div.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.op_AdditionAssignment(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CMat)">
 <summary>
 Adds one matrix to another.
 </summary>
 <param name="m1">The left matrix. This matrix is modified.</param>
 <param name="m2">The right matrix</param>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.r(System.Int32,System.Int32)">
 <summary>
 Get real value
 </summary>
 <param name="i">Row</param>
 <param name="j">Column</param>
 <returns>Real</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.i(System.Int32,System.Int32)">
 <summary>
 Get imaginary value
 </summary>
 <param name="i">Row</param>
 <param name="j">Column</param>
 <returns>Imaginary</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.Rs">
 <summary>
 The real parts of the matrix elements, as an array of arrays.
 This property is for use when performance-optimized bulk access to the matrix elements is required.
 In most cases, it is simpler (and not much slower) to use the 
 <see cref="P:Microsoft.Research.Liquid.CMat.Item(System.Int32,System.Int32)">Item</see> 
 property instead.
 </summary>
 <returns>An array of arrays of real parts</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.LengthR">
 <summary>
 The number of rows in the matrix.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.LengthC">
 <summary>
 The number of columns in the matrix.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.Length">
 <summary>
 The number of rows or columns in the matrix, for square matrices.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.Item(System.Int32,System.Int32)">
 <summary>
 Gets an individual element of the matrix, as a Complex number.
 </summary>
 <param name="i">The row index.</param>
 <param name="j">The column index.</param>
 <returns>The complex value of the matrix element.</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CMat.Is">
 <summary>
 The imaginary parts of the matrix elements, as an array of arrays.
 This property is for use when performance-optimized bulk access to the matrix elements is required.
 In most cases, it is simpler (and not much slower) to use the 
 <see cref="P:Microsoft.Research.Liquid.CMat.Item(System.Int32,System.Int32)">Item</see> 
 property instead.
 </summary>
 <returns>An array of arrays of imaginary parts</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Write(System.IO.BinaryWriter)">
 <summary>
 Writes this matrix to a stream for serialization.
 </summary>
 <param name="bw">A BinaryWriter to serialize this matrix to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.UnitaryError">
 <summary>
 Performs a rough check to see if this matrix is actually unitary.
 It calculates the biggest deviation from 1 of the diagonal elements
 of (this adj)*this.
 In other words, it calculates the largest deviation of the length of a row,
 viewed as a complex vector, from 1.
 The orthogonality of different rows is not checked.
 </summary>
 <returns>The worst deviation from 1.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.ToString">
 <summary>
 Gets a string representation of this matrix.
 Note that there is no limit on the size of the result; every row and column entry is included.
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Read(System.IO.BinaryReader)">
 <summary>
 Reads a matrix from a stream.
 </summary>
 <param name="br">A BinaryReader to deserialize a matrix from.</param>
 <returns>The new mnatrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Power(System.Int32)">
 <summary>
 Computes an integer power of this matrix.
 NOTE: This destroys the contents of the current matrix.
 </summary>
 <param name="n">The power to raise this matrix to; must be greater than 0.</param>
 <returns>The resulting matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Mul(System.Int32,System.Int32,Microsoft.Research.Liquid.CMat,System.Int32,System.Int32,Microsoft.Research.Liquid.CMat,System.Int32,System.Int32)">
 <summary>
 Efficient multiply
 </summary>
 <param name="i3">Dest row in this matrix</param>
 <param name="j3">dest col in this matrix</param>
 <param name="m1">Left matrix</param>
 <param name="i1">Src row in left matrix</param>
 <param name="j1">Src col in left matrix</param>
 <param name="m2">Right matrix</param>
 <param name="i2">Src row in right matrix</param>
 <param name="j2">Src col in right matrix</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Mul(System.Double)">
 <summary>
 Scales this matrix by a constant multiplier.
 This matrix is updated in place, rather than a new matrix being created.
 </summary>
 <param name="mul">The scale factor to multiply by.</param>
 <returns>This matrix, as updated after scaling</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Mul(Microsoft.Research.Liquid.CMat)">
 <summary>
 Computes the product of this matrix with another matrix.
 This matrix is on the left-hand side of the product, 
 and the argument matrix is on the right-hand side.
 This matrix must have the same number of columns as the other matrix has rows.
 </summary>
 <param name="m2">The second matrix.</param>
 <returns>The resulting product matrix.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Mul(Microsoft.FSharp.Core.FSharpRef{System.Double},Microsoft.FSharp.Core.FSharpRef{System.Double},System.Int32,System.Int32,Microsoft.Research.Liquid.CMat,System.Int32,System.Int32)">
 <summary>
 Efficient complex multiply and accumulate
 </summary>
 <param name="tmpR">Real accumulator</param>
 <param name="tmpI">Imaginary accumulator</param>
 <param name="i1">Row index in left matrix</param>
 <param name="j1">Col index in left matrix</param>
 <param name="m2">Right matrix</param>
 <param name="i2">Row index in right matrix</param>
 <param name="j2">Col index in right matrix</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Mul(Microsoft.Research.Liquid.CVec,System.UInt64,Microsoft.Research.Liquid.CVec,Microsoft.FSharp.Core.FSharpRef{System.Double},Microsoft.FSharp.Core.FSharpRef{System.Double})">
 <summary>
 M*V In place partial multiply (block diagonal repeated matrix). Vector is updated
 </summary>
 <param name="v">Full vector to multiply</param>
 <param name="offset">Offset into vector</param>
 <param name="vTmp">re-used vector buffer (same save as matrix rows)</param>
 <param name="tmpR">re-used temporary real value</param>
 <param name="tmpI">re-used temporary imaginary value</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Mul(Microsoft.Research.Liquid.CVec)">
 <summary>
 Calculates the product of this matrix and a vector.
 The vector's length must match the numder of columns in this matrix.
 </summary>
 <param name="v">The vector to multiply</param>
 <returns>The resulting product vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Kron(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Computes the Kronecker Product of this matrix with an identity matrix
 </summary>
 <param name="len">The dimension of the identity matrix (N of NxN).</param>
 <param name="left">An option that, if true, specifies that the identity matrix
 should be on the left side of the Kronecker product.
 The default is false, which means that the identity is on the right.</param>
 <returns>The result of the Kronecker product</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Kron(Microsoft.Research.Liquid.CMat)">
 <summary>
 Computes the Kronecker Product of this matrix with another matrix.
 </summary>
 <param name="m2">The right-hand side matrix in the Kronecker product.</param>
 <returns>The result of the Kronecker product</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.FixUnitary(Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Makes this matrix closer to being unitary by applying an iterative correction.
 </summary>
 <param name="tol">An optional desired tolerance for the deviation from unitarity,
 as measured by <see cref="M:Microsoft.Research.Liquid.CMat.UnitaryError"></see>. 
 The default is 1.0e-13.</param>
 <param name="maxIter">An optional maximum number of iterations to perform.
 The default is 5.</param>
 <returns>A tuple of the number of iterations performed, for cost estimates, 
 and the final deviation from unitarity.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.ExpM">
 <summary>
 Quick and dirty matrix exponential (e^M)
 </summary>
 <returns>Exponentiated matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.DumpNarrow(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this matrix.
 This method will produce a relatively compact representation of the matrix.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.DumpML(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this matrix in Matlab format for debugging.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="prec">precision 0=low 1=normal 2=high 3=full (optional=1)</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this matrix.
 Note that there is no limit on the size of the result; every row and column entry is included.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Div(System.Double)">
 <summary>
 Scales this matrix by a constant divisor.
 This matrix is updated in place, rather than a new matrix being created.
 </summary>
 <param name="div">The scale divisor. The matrix is multiplied by 1/div.</param>
 <returns>This matrix, as updated after scaling</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.CreZer(System.Int32,System.Int32)">
 <summary>
 Creates an array filled with zeros that can be filled in and passed to the 
 <see cref="M:Microsoft.Research.Liquid.CMat.#ctor(System.Double[][],System.Double[][])">array-based CMat constructor</see>.
 </summary>
 <param name="lenR">The number of rows</param>
 <param name="lenC">The number of columns</param>
 <returns>The new array</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.CreMat(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double}})">
 <summary>
 Creates an array that can be filled in and passed to the 
 <see cref="M:Microsoft.Research.Liquid.CMat.#ctor(System.Double[][],System.Double[][])">array-based CMat constructor</see>.
 </summary>
 <param name="lenR">The number of rows</param>
 <param name="lenC">The number of columns</param>
 <param name="f">The function to call to compute the elements of the array.
 It will get called with the row first and then the column (curried).</param>
 <returns>The new array</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Copy">
 <summary>
 Makes a new copy, independent copy of this matrix.
 </summary>
 <returns>The new matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Clear">
 <summary>
 Clears this matrix, setting it to a 0x0 matrix.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Adj">
 <summary>
 Computes the adjoint (complex conjugate transpose) of this matrix.
 </summary>
 <returns>The adjoint matrix</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.Add(Microsoft.Research.Liquid.CMat)">
 <summary>
 Adds another matrix to this matrix.
 The two matrices must have the same number of rows and columns.
 </summary>
 <param name="m2">The matrix to add to this one.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.#ctor(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double,System.Double}})">
 <summary>
 Creates a square matrx from a sparse list of elements.
 </summary>
 <param name="len">The row (or column) length of the matrix.</param>
 <param name="xyris">A list of element location and value tuples,
 with elements in the order (row,col,real,imag).</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a square identity or zero matrix.
 </summary>
 <param name="n">The row (or column) length of the matrix.</param>
 <param name="zero">Option to initialize to a zero matrix rather than to the identity matrix. 
 The default is to initialize to the identity.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CMat.#ctor(System.Double[][],System.Double[][])">
 <summary>
 Creates a new matrix from arrays of real and imaginary parts.
 </summary>
 <param name="rs">The real part of each matrix element.</param>
 <param name="is">The real part of each matrix element.</param>
</member>
<member name="T:Microsoft.Research.Liquid.CMat">
 <summary>
 A dense matrix of complex numbers.
 <seealso cref="T::Microsoft.Research.Liquid.CSMat"/>
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.rSafe(System.UInt64,System.Double)">
 <summary>
 Sets the real part of an element of this vector by index.
 </summary>
 <param name="i">The index of the element to set</param>
 <param name="i">The value to set the real part of the element to</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.r(System.UInt64,System.Double)">
 <summary>
 Set real part of an item by index (unsafe, use with CARE)
 </summary>
 <param name="i">index</param>
 <param name="v">real value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.iSafe(System.UInt64,System.Double)">
 <summary>
 Sets the imaginary part of an element of this vector by index.
 </summary>
 <param name="i">The index of the element to set</param>
 <param name="i">The value to set the imaginary part of the element to</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.i(System.UInt64,System.Double)">
 <summary>
 Set imaginary part of an item by index (unsafe, use with CARE)
 </summary>
 <param name="i">index</param>
 <param name="v">imaginary value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Safe(System.UInt64,Microsoft.Research.Liquid.Complex)">
 <summary>
 Sets an element of this vector by index.
 </summary>
 <param name="i">The index of the element to set</param>
 <param name="c">The Complex value to set for the element</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Safe(System.Int32,System.Int32,Microsoft.Research.Liquid.Complex)">
 <summary>
 Safe set of an item (allocates as necessary)
 </summary>
 <param name="b">Block index</param>
 <param name="i">Sub-block index</param>
 <param name="c">Complex value</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Item(System.UInt64,Microsoft.Research.Liquid.Complex)">
 <summary>
 Sets an element of this vector by index.
 <para>
 NOTE: This method is unsafe. 
 If the index points to a block of zero elements in the vector,
 and the vector was allocated sparsely, then this method may cause a null pointer exception.
 The <see cref="CVec.Safe">CVec.Safe</see> property should be used instead.
 </para>
 </summary>
 <param name="i">The index of the element to set</param>
 <param name="c">The Complex value to set</param>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Item(System.Int32,System.Int32,Microsoft.Research.Liquid.Complex)">
 <summary>
 Set an item by block and sub-block index (unsafe, use with CARE)
 </summary>
 <param name="b">block</param>
 <param name="i">sub-block</param>
 <param name="c">Complex value</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.op_MultiplyBang(Microsoft.Research.Liquid.CVec,Microsoft.Research.Liquid.CVec)">
 <summary>
 Computes the Kronecker product of two vectors.
 </summary>
 <param name="v1">Left vector</param>
 <param name="v2">Right vector</param>
 <returns>The result vector</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.rSafe(System.UInt64)">
 <summary>
 Gets the real part of an element of this vector by index.
 </summary>
 <param name="i">The index of the element to get</param>
 <returns>The real part of the Complex value of the element</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.r(System.UInt64)">
 <summary>
 Get real part of an item by index (unsafe, use with CARE)
 </summary>
 <param name="i">index</param>
 <returns>real part of complex</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.iSafe(System.UInt64)">
 <summary>
 Gets the imaginary part of an element of this vector by index.
 </summary>
 <param name="i">The index of the element to get</param>
 <returns>The imaginary part of the Complex value of the element</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.i(System.UInt64)">
 <summary>
 Get imaginary part of an item by index (unsafe, use with CARE)
 </summary>
 <param name="i">index</param>
 <returns>imaginary part of complex</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Safe(System.UInt64)">
 <summary>
 Gets an element of this vector by index.
 </summary>
 <param name="i">The index of the element to get</param>
 <returns>The Complex value of the element</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Safe(System.Int32,System.Int32)">
 <summary>
 Gets an element of this vector by block and index within block.
 </summary>
 <param name="b">The block number of the element</param>
 <param name="i">The element's index within the block</param>
 <returns>The Complex value of the element</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Length">
 <summary>
 The length of this vector
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Item(System.UInt64)">
 <summary>
 Gets an element of this vector by index.
 <para>
 NOTE: This method is unsafe. 
 If the index points to a block of zero elements in the vector,
 and the vector was allocated sparsely, then this method may cause a null pointer exception.
 The <see cref="CVec.Safe">CVec.Safe</see> property should be used instead.
 </para>
 </summary>
 <param name="i">The index of the element to get</param>
 <returns>The Complex value of the element</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.Item(System.Int32,System.Int32)">
 <summary>
 Get an item by block and sub-block index (unsafe, use with CARE)
 </summary>
 <param name="b">block</param>
 <param name="i">sub-block</param>
 <returns>Complex value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.BlkLenL">
<summary>
 Return length of a block N = 2^N entries as a long
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.BlkLen">
<summary>
 Return length of a block as 2^N (2^BlkBits)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.BlkFinal">
<summary>
 Return index of final block    
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.BlkCnt">
<summary>
 The number of blocks in this vector.
 Note that some blocks might be empty if the vector was built sparse.
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.CVec.BlkBits">
<summary>
 The length of a block as N (there are 2^N entries)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.blkR(System.Int32)">
<summary>
 Force allocation of a real block
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.blkI(System.Int32)">
<summary>
 Force allocation of an imaginary block
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Zero">
 <summary>
 Zeroes this vector.
 Note that this also densely fills in the vector.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Write(System.IO.BinaryWriter)">
 <summary>
 Writes this vector to a binary file.
 <seealso cref="M:Microsoft.Research.Liquid.CVec.Read(System.IO.BinaryReader)"/>
 </summary>
 <param name="bw">The BinaryWriter that this vector should be written to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.ToString">
 <summary>
 Converts this vector to a string.
 At most the first 512 entries are displayed.
 </summary>
 <returns>The string</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Scale(Microsoft.Research.Liquid.Complex)">
 <summary>
 Scale all elements of the vector (unsafe)
 </summary>
 <param name="scale">Complex scale factor</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Rev">
 <summary>
 Reverse a vector in place
 </summary>
 <returns>Ourself (for chaining operations)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Read(System.IO.BinaryReader)">
 <summary>
 Reads a new vector from a binary file.
 Note that this routine is only intended to read vectors written with the
 <see cref="M:Microsoft.Research.Liquid.CVec.Write(System.IO.BinaryWriter)">Write</see> method.
 <seealso cref="M:Microsoft.Research.Liquid.CVec.Write(System.IO.BinaryWriter)"/>
 </summary>
 <param name="br">The BinaryReader from which the vector should be read.</param>
 <returns>The new vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Permute(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Permute state vector with a bit list (lowest bit first)
 </summary>
 <param name="width">Number of bits</param>
 <param name="pairs">Pairs to swap</param>
 <param name="threads">Threads to use (optional=num cores)</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Pairs(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
 <summary>
 Create a pairwise exchange to permute a state (as well as final order)
 </summary>
 <param name="idxs">desired order of elements we care about</param>
 <returns>pair swaps and new order of all elements</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Normalize(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>
 Normalizes this vector to length 1.0.
 </summary>
 <param name="len">The optional current length, if already calculated.
 The default is to invoke and use the result of 
 <see cref="M:Microsoft.Research.Liquid.CVec.AddMCC">AddMCC</see></param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.NonZeros(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>
 Gets non-zero indices upto a max count
 </summary>
 <param name="mx">Max length of list to return</param>
 <param name="thresh">Threshold (optional=tol*1.0e+2)</param>
 <returns>Indicies of non-zero (tolerance defined) entries</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Mul(System.UInt64,Microsoft.Research.Liquid.CVec,System.UInt64,Microsoft.Research.Liquid.CVec,System.UInt64)">
 <summary>
 Efficient multiply
 </summary>
 <param name="i3">Index of target in this vector</param>
 <param name="v1">Left source vector</param>
 <param name="i1">Left source index</param>
 <param name="v2">Right source vector</param>
 <param name="i2">Right source index</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.MCC(System.UInt64)">
 <summary>
 Multiply complex conjugate of an item
 </summary>
 <param name="j">Index of item</param>
 <returns>Complex Conjugate (magnitude squared)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.MCC(System.Int32,System.Int32)">
 <summary>
 Multiply complex conjugate of an item
 </summary>
 <param name="b">Block</param>
 <param name="j">sub-block</param>
 <returns>Complex Conjugate (magnitude squared)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Kron(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.CVec})">
 <summary>
 Kronecker product of a list of vectors (**DESTROYS** all inputs to reclaim space)
 </summary>
 <param name="vs">List of vectors to muliply</param>
 <returns>result vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Kron(Microsoft.Research.Liquid.CVec)">
 <summary>
 Computes the Kronecker product of this vector and another.
 </summary>
 <param name="v2">Vector to multiply this one by</param>
 <returns>The result vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.IdxI(System.UInt64)">
<summary>
 Get sub-block index (inside of a block) for an item index
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.IdxB(System.UInt64)">
<summary>
 Get block index from an item index
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.GlobalPhase">
 <summary>
 Estimates the global phase of a vector that represents a quantum state.
 The estimate is computed as the complex phase of the vector element with
 the greatest amplitude.
 </summary>
 <returns>A tuple whose first element is the estimated phase angle, in radians,
 and whose second element is the unit-magnitude Complex number with the 
 opposite phase.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.DumpMCC(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dump vector MCC with provided function
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="thresh">Output threshold (optional=tol*1.e+2)</param>
 <param name="both">Output complex value as well (optional=false)</param>
 <param name="maxNZ">Max non-zeros to dump (optional=256)</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this vector using the provided function.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="maxNZ">The optional maximum number of  non-zeros to dump. The default is 256</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Copy">
 <summary>
 Creates an exact copy of this vector.
 </summary>
 <returns>The new vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Clear">
 <summary>
 Return all memory (everything unsafe after this)
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.BlkR(System.UInt64)">
 <summary>
 Direct access of an entire block of reals from an item index (unsafe, use with CARE)
 </summary>
 <param name="i">Item index</param>
 <returns>Block of reals</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.BlkR(System.Int32)">
 <summary>
 Gets a block of the vector, real parts only.
 <para>
 NOTE: This method is unsafe. 
 If the index points to a block of zero elements in the vector,
 and the vector was allocated sparsely, then this method may return a null pointer.
 </para>
 </summary>
 <param name="b">Block to access</param>
 <returns>The vector of real partss</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.BlkI(System.UInt64)">
 <summary>
 Direct access of an entire block of imaginaries from an item index (unsafe, use with CARE)
 </summary>
 <param name="i">Item index</param>
 <returns>Block of imaginaries</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.BlkI(System.Int32)">
 <summary>
 Gets a block of the vector, imaginary parts only.
 <para>
 NOTE: This method is unsafe. 
 If the index points to a block of zero elements in the vector,
 and the vector was allocated sparsely, then this method may return a null pointer.
 </para>
 </summary>
 <param name="b">Block to access</param>
 <returns>Block of imaginaries</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.Bits(System.Int32)">
 <summary>
 Calculates the number of bits needed to represent a positive integer.
 </summary>
 <param name="n">The integer to represent</param>
 <returns>The number of bits required</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.AddMCC">
 <summary>
 Calculates the norm of this vector.
 The norm is the square root of the sum of the complex magnitudes of the vector elements.
 </summary>
 <returns>This vector's norm</returns>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.#ctor(System.UInt64,System.Boolean)">
 <summary>
 Creates a new vector filled with zeroes.
 </summary>
 <param name="_len">The length of the vector</param>
 <param name="force">Option to force complete (non-sparse) allocation of 
 the vector. The default to false, which leaves the vector sparse.</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.#ctor(System.Double[],Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a new  vector from initial value vectors, real and imaginary.
 Note that the length of the new vector must be no more than 2^20.
 </summary>
 <param name="rs">The vector of real initial values</param>
 <param name="is">An optional vector of imaginary initial values; default is zero</param>
 <param name="force">Option to force complete (non-sparse) allocation of 
 the vector; defaults to false</param>
</member>
<member name="M:Microsoft.Research.Liquid.CVec.#ctor(System.UInt64,Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a new  vector.
 By default, the vector is all zero.
 Optionally, the real and impaginary initial values may be provided;
 in this case, the vector must be no more than 2^20 in length.
 </summary>
 <param name="_len">The length of the vector</param>
 <param name="rsInit">Optional real parts of the initial values; if provided, there
 must be an entry for each element in the vector. Default is zero.</param>
 <param name="isInit">Optional imaginary of the initial values; if provided, there
 must be an entry for each element in the vector. Default is zero.</param>
 <param name="forceAlloc">Option to force complete (non-sparse) allocation of 
 the vector; defaults to false</param>
</member>
<member name="T:Microsoft.Research.Liquid.CVec">
<summary>
 A block-sparse vector of complex numbers.
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Item(System.Int32,`0)">
 <summary>
 Set an item and grow if necessary.
 </summary>
 <param name="i">Index to address.</param>
 <param name="v">Value to set.</param>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Data(`0[])">
 <summary>
 Get/Set raw data array
 </summary>
 <returns>data array</returns>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Stats">
<summary>
 Get statistics: iniSiz,bufSiz,numAllocs
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Length">
<summary>
 Active length (1+last added item).
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Item(System.Int32)">
 <summary>
 Get an item
 </summary>
 <param name="i">Index to address.</param>
 <returns>Item.</returns>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Data">
 <summary>
 Get/Set raw data array
 </summary>
 <returns>data array</returns>
</member>
<member name="P:Microsoft.Research.Liquid.DynAry`1.Allocated">
 <summary>
 Allocated length.
 </summary>
 <value>Elements allocated.</value>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.TypeClear">
 <summary>
 Clear out the cache of static allocations
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.ReAlloc(System.Int32)">
 <summary>
 Reallocate an old DynAry
 </summary>
 <param name="iniSiz2">New min size</param>
 <returns>Allocation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.GlobalClear">
 <summary>
 Clear out the cache of static allocations
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.Free">
 <summary>
 Return a statically allocated DynAry to its cache
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.Clear">
<summary>
 Clear out used length.
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.Alloc(System.Int32)">
 <summary>
 Get a Dynamic array from a cache
 </summary>
 <param name="iniSiz">Initial Size if we need a new one</param>
 <returns>DynAry</returns>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.Add">
<summary>
 Add to end of used length (return the default value)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.Add(`0)">
<summary>
 Add to end of used length.
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.DynAry`1.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Simple dynamic array implementation.
 </summary>
 <param name="iniSiz">Initial size (optional=10)</param>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.TraceRun(System.Int32)">
<summary>
 Trace a circuit run (0=none 1=to log 2=to log and console, 3=Ket dumps)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Threads(System.Int32)">
<summary>
 Get/Set Threads for Kronecker
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">
 <summary>
 Symbol table used to store the results of joint parity measurements.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.RandSeed(System.Int32)">
<summary>
 Force the pseudo-random number gen to a known initial state
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Quiet(System.Boolean)">
 <summary>
 get/set Quiet for Gate or Circuit building
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.PermLimit(System.Int32)">
<summary>
 Debug permutation code by forcing it all the time
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Mode(Microsoft.Research.Liquid.KetMode)">
 <summary>
 get/set KetMode for Gate or Circuit building
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.MeasureFun(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Bit,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}})">
 <summary>
 Set Measure function for v2 symbol table building
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.ChkAbort(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Function to throw exception if abort is desired (mostly used in ensemble mode)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.TraceRun">
<summary>
 Trace a circuit run (0=none 1=to log 2=to log and console, 3=Ket dumps)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Threads">
<summary>
 Get/Set Threads for Kronecker
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Symbol(System.String)">
 <summary>
 Symbol table used to store the results of joint parity measurements.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Rnd">
<summary>
 Ask for a random number generator
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.RandSeed">
<summary>
 Force the pseudo-random number gen to a known initial state
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Quiet">
 <summary>
 get/set Quiet for Gate or Circuit building
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Qubits">
<summary>
 Get all qubits in ID order
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Perms">
<summary>
 Permutation stats (gate,state,none)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.PermLimit">
<summary>
 Debug permutation code by forcing it all the time
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Parts">
 <summary>
 Get indivdual parts inside the state (used internally)
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Mode">
 <summary>
 get/set KetMode for Gate or Circuit building
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.MeasureFun">
 <summary>
 Set Measure function for v2 symbol table building
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.MaxEntangled">
<summary>
 Max entangled that we&apos;ve seen (reset during Reset())
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Item(System.Int32)">
<summary>
 Get a specific qubit in our state (by qubit ID)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.IsCircuit">
<summary>
 Are we in circuit building mode?
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.Count">
<summary>
 Count of Qubits in state
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Ket.ChkAbort">
<summary>
 Function to throw exception if abort is desired (mostly used in ensemble mode)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Write(System.String)">
 <summary>
 Writes this state vector to a file.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Write(System.IO,BinaryWriter)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.String)"/>
 </summary>
 <param name="file">The name of the file that this Ket should be written to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Write(System.IO.BinaryWriter)">
 <summary>
 Writes this state vector to a binary stream.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Write(System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.IO.BinaryReader)"/>
 </summary>
 <param name="bw">The stream that this Ket should be written to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Validate(Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Check integrety of ket vector. Makes sure vLen = 2^qCnt and vector length = 1
 </summary>
 <param name="msg">Optional message tag to output on error</param>
 <exception>Throws an exception if found to be invalid</exception>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.ToString">
 <summary>
 Gets a string representation of this Ket.
 This string may be extremely long; in general, it will have 2^N lines if there are N qubits in the Ket.
 Generally it is better to use the 
 <see cref="M:Microsoft.Research.Liquid.Ket.DumpKP(Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 Dump</see> method instead.
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.StateSet(Microsoft.Research.Liquid.Qubit,Microsoft.Research.Liquid.CVec)">
<summary>
 Set a qubit state (if un-entangled). Autonormalizes length
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.State(Microsoft.Research.Liquid.Qubit)">
<summary>
 Get a qubit state (if un-entangled)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.SplitParts(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Split ket into its constituant parts
 </summary>
 <param name="shallow">Do a shallow copy? (optional=true)</param>
 <returns>List of KetParts as individual Kets in same order</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Split(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Split into multiple Ket vectors based on a list of lists of qubits.
 Note that this is ONLY legal if each of the lists is un-entangled with the others
 </summary>
 <param name="qss">List of lists of qubits to split Ket vector into</param>
 <param name="check">Optionally check that the lists were actually un-entangled (expensive, optional=false)</param>
<returns>List of split Ket vectors</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Single(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}})">
 <summary>
 Treats this Ket as if all of its qubits are entangled.
 </summary>
 <param name="order">Optionally, a list specifying a new order for the qubits.
 The default is for qubits to remain in their current order.</param>
 <returns>A CVec that contains the single state vector.
 Note that it is unsafe to modify this vector.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Reset(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Bit})">
 <summary>
 Resets this Ket to an initial state with a specified number of qubits.
 </summary>
 <param name="want">An optional new qubit count.
 The default is to keep the same number of qubits.</param>
 <param name="init">An optional initial value for all qubits.
 The default is Zero.</param>
 <returns>The new Qubits in this Ket</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Read(System.String)">
 <summary>
 Reads a new state vector from a file.
 Note that this routine is only intended to read vectors written with the
 <see cref="M:Microsoft.Research.Liquid.Ket.Write(System.String)">Write</see> method.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.IO.BinaryReader)"/>
 </summary>
 <param name="file">The name of the file from which the state vector should be read.</param>
 <returns>The new Ket</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Read(System.IO.BinaryReader)">
 <summary>
 Reads a new state vector from a binary stream.
 Note that this routine is only intended to read vectors written with the
 <see cref="M:Microsoft.Research.Liquid.Ket.Write(System.IO.BinaryWriter)">Write</see> method.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.String)"/>
 </summary>
 <param name="br">The stream from which the vector should be read.</param>
 <returns>The new Ket</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.ReAnimate(Microsoft.Research.Liquid.Qubit)">
<summary>
 Reanimate a measured qubit to its measured value
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.ReAnimate(Microsoft.Research.Liquid.Qubit,Microsoft.Research.Liquid.CVec)">
<summary>
 Reanimate a measured qubit (use with caution)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Purity">
 <summary>
 Finds the purity of each qubit in this Ket. NOT OPTIMIZED.
 </summary>
 <returns>An array of purities</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Probs(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Get the state probabilities for a list of qubits (l.e. 10 qubits)
 </summary>
 <param name="qs">Qubits to fake measure</param>
 <returns>Array of state values (low bit=first qubit requested)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.ProbOdd(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Get the probability of measuring odd parity for a set of qubits
 </summary>
 <param name="qs">Qubits to fake measure</param>
 <param name="basis">String of basis to use for each qubit (optional="Z")</param>
 <returns>Probability of odd parity</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Prob1(Microsoft.Research.Liquid.Qubit)">
 <summary>
 Get the probability of measuring 1 for a single qubit
 </summary>
 <param name="q">Qubit to "fake" measure</param>
 <returns>probability</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.NormDiff(Microsoft.Research.Liquid.CVec)">
 <summary>
 Get L2 Norm of the difference of two ket vectors
 </summary>
 <param name="v2">Target ket vector to diff (obtained by ket.Single())</param>
 <returns>L2 Norm of the difference</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Meas(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Bit})">
 <summary>
 Measure: Observe the state (and collapse it).
 </summary>
 <param name="qsIn">First qubit in list is the one measured</param>
 <param name="force">Force a measurement value (optional=Unknown)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Kraus(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.KrausOp},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Apply Kraus operators for a channel
 </summary>
 <param name="kraus">List of Kraus matrices</param>
 <param name="qs">Qubits to operate on</param>
 <param name="name">Optional name for POVM index store (default="")</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.KetPart(Microsoft.Research.Liquid.Qubit)">
 <summary>
 Get the KetPart the contains this qubit (used internally)
 </summary>
 <param name="q">Qubit that we want</param>
 <returns>KetPart,Index (Index in High to Low order)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.JointMeas(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Do a joint parity measurement
 </summary>
 <param name="sym">Symbol name to store under</param>
 <param name="qs">Qubits to measure</param>
 <param name="basis">String of basis to use for each qubit (optional="Z")</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Join(Microsoft.Research.Liquid.Ket)">
 <summary>
 Joins another Ket to the end of this one (added Ket is NOT usable after this)
 </summary>
 <param name="kAdd">ket to add at the end</param>
 <returns>Resulting ket</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Free(Microsoft.Research.Liquid.Qubit)">
 <summary>
 Frees a qubit from the state vector (will be measured if it isn't already).
 </summary>
 <param name="q">Qubit to free.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.EvalOp(Microsoft.Research.Liquid.CSMat,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Evaluate an operation (Qubits come in in operator order (high to low))
 </summary>
 <param name="op">Operator to execute</param>
 <param name="qsIn">Qubits to operat on (must be from this Ket vector)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Entropy(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}})">
 <summary>
 Get the entanglement entropy
 </summary>
 <param name="alpha">Denotes the generalized entropy parameter: 1 for Von Neumann or 2 for Reny</param>
 <param name="qPos">qubit position, 0 to nQubits (based on order)</param>
 <param name="order">Int list of qubit order to wind up in []=use results of previous call (optional=[0..N-1])</param>
 <returns>Entropy value</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Entangled(Microsoft.Research.Liquid.Qubit)">
<summary>
 Check if qubit is entangled
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.DumpKP(Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Dump the portion of this state vector that includes a specific qubit and 
 all of the qubits it is entangled with.
 If this Ket is a product state, then only the factor containing the
 specified qubit is dumped.
 </summary>
 <param name="q">The Qubit that iodentifies the product state factor.</param>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="doMCC">An option that, if true, causes probabilities (complex magnitude squared) to be output
 for each state entry, rather than the complex amplitude.
 The default is to output the complex amplitude for each state.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Dump this state vector.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="doMCC">An option that, if true, causes probabilities (complex magnitude squared) to be output
 for each state entry, rather than the complex amplitude.
 The default is to output the complex amplitude for each state.</param>
 <param name="doSort">An option that, if true, causes the output to be sorted in qubit ID order.
 The default is to sort the output.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Copy">
 <summary>
 Makes a new Ket that is a deep copy of this Ket.
 </summary>
 <returns>The new ket vector</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Bit(Microsoft.Research.Liquid.Qubit)">
<summary>
 Check if a qubit is measured (Zero,One or Unknown)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.AddKP(Microsoft.Research.Liquid.KetPart)">
 <summary>
 Add a ketPart to a ket. Usually only used inside of Read()
 </summary>
 <param name="kp"></param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Add(System.Int32,Microsoft.Research.Liquid.Bit)">
 <summary>
 Adds multiple qubits to the state, all with the same classical Bit value.
 The new qubits are unentangled and have the provided state.
 Note that the new qubits are not considered measured.
 </summary>
 <param name="cnt">The number of qubits to add.</param>
 <param name="b">The initial state of the added qubits.</param>
 <returns>The new Qubits</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Add(Microsoft.Research.Liquid.Bit)">
 <summary>
 Adds a new qubit to the state with a classical Bit value.
 The new qubit is unentangled and has the provided state.
 Note that the new qubit is not considered measured.
 </summary>
 <param name="b">The initial state of the added qubit.</param>
 <returns>The new Qubit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Add(Microsoft.Research.Liquid.CVec)">
 <summary>
 Adds a new qubit to the state with a complex state vector.
 The new qubit is unentangled and has the provided state.
 </summary>
 <param name="cv">The state of the added qubit.</param>
 <returns>The new Qubit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Add(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Add a new qubit to the state (real and imaginary values, auto-normalized)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Add(System.Double,System.Double)">
<summary>
 Add a new qubit to the state (real values, auto-normalized)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.Add(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
<summary>
 Add a new qubit to the state (complex vector is auto-normalized)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.#ctor">
 <summary>
 Creates an empty Ket vector.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Bit})">
 <summary>
 Creates a populated Ket vector.
 </summary>
 <param name="count">Number of qubits to allocate.</param>
 <param name="init">An optional initial value for the qubits, either Zero or One.
 The default is to initialize all qubits to Zero.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Ket.#ctor(System.Int32,Microsoft.Research.Liquid.Bit,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.KetPart},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Create a Ket vector
 </summary>
 <param name="count">Count of initial qubits (optional=0)</param>
 <param name="init">Initial value for qubits (optional=Zero)</param>
 <param name="kOld">KetPart list to init from (state entries are shared) (optional=None)</param>
 <param name="shallow">Do a shallow copy? (optional=true)</param>
</member>
<member name="T:Microsoft.Research.Liquid.Ket">
 <summary>
 Represents a state vector.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.KetPart.Write(System.IO.BinaryWriter)">
 <summary>
 Write out a ket part for serialization
 </summary>
 <param name="bw">BinaryWriter</param>
</member>
<member name="M:Microsoft.Research.Liquid.KetPart.ToString">
<summary>
 Output to a string
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.KetPart.Split(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Split a single KetPart in two
 Note that this is ONLY legal if list provided is un-entangled with the others
 </summary>
 <param name="qs1">List of qubits to put in first KetPart returned</param>
<returns>Two KetParts in a list (first is the qubits we asked for). If we can't split returns a singleton list</returns>
</member>
<member name="M:Microsoft.Research.Liquid.KetPart.Read(System.IO.BinaryReader,Microsoft.Research.Liquid.Ket)">
 <summary>
 Read in a Ket Part
 </summary>
 <param name="br">Binary Reader</param>
 <param name="ket">State vector</param>
 <returns>New KetPart</returns>
</member>
<member name="M:Microsoft.Research.Liquid.KetPart.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 State dump (ordered if only 1 block long)
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="doMCC">Optional only do MCC values (default=false)</param>
 <param name="doSort">Sort qubits? (default=true)</param>
</member>
<member name="M:Microsoft.Research.Liquid.KetPart.Copy(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Shallow or Deep copy of this KetPart (both qubits and vectors)
 </summary>
 <param name="kNew">Target Ket</param>
 <param name="shallow">Force shallow copy (optional=true)</param>
 <param name="qBase">Qubit Id base (optional=0)</param>
 <returns>New KetPart for target Ket</returns>
</member>
<member name="T:Microsoft.Research.Liquid.KetPart">
 <summary>
 Entangled piece of state vector
 <p>Default Constructor:</p>
 <c>   {qs:Qubit list;v:CVec}</c>
 <ul>
 <li>qs: Qubits that make up this section of the state</li>
 <li>v: Complex Vector that goes with the qubits</li>
 </ul>
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.Qubits">
 <summary>
 Qubits is shorthand for Qubit list
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Type(System.String)">
 <summary>
 The type of the qubit.
 This is only used for noise modeling.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Bit(Microsoft.Research.Liquid.Bit)">
 <summary>
 The measured value of a qubit in the computational basis.
 This will be Unknown if the qubit has not been measured since it last interacted.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Zero">
 <summary>
 A Complex vector that represents the state |0> in the computational basis.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Type">
 <summary>
 The type of the qubit.
 This is only used for noise modeling.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.State">
 <summary>
 The state vector for this qubit, if it is unentangled.
 This property will raise an exception if the qubit is entangled.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Prob1">
 <summary>
 The probability of this qubit being 1.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.One">
 <summary>
 A Complex vector that represents the state |1> in the computational basis.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Ket">
<summary>
 State we belong to
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Id">
<summary>
 Wire number in Ket vector
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Entangled">
 <summary>
 Whether or not this qubit is entangled.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Qubit.Bit">
 <summary>
 The measured value of a qubit in the computational basis.
 This will be Unknown if the qubit has not been measured since it last interacted.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit._fmv(Microsoft.Research.Liquid.Bit)">
<summary>
 Only used internally (unsafe)!
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.Write(System.IO.BinaryWriter)">
 <summary>
 Write a qubit for serialization
 </summary>
 <param name="bw">BinaryWriter to use</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ToString">
 <summary>
 Creates a string representation of this Qubit.
 The representation shows the current state of the qubit if it is unentangled.
 <seealso cref="M:Microsoft.Research.Liquid.Qubit.ShowMag()"/>
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.StateSet(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
 <summary>
 Sets the state vector for this qubit, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
 <param name="c1">The complex |0> amplitude to set this qubit's state to.</param>
 <param name="c2">The complex |1> amplitude to set this qubit's state to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.StateSet(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Sets the state vector for this qubit, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
 <param name="r1">The real part of the |0> amplitude to set this qubit's state to.</param>
 <param name="i1">The imaginary part of the |0> amplitude to set this qubit's state to.</param>
 <param name="r2">The real part of the |1> amplitude to set this qubit's state to.</param>
 <param name="i2">The imaginary part of the |1> amplitude to set this qubit's state to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.StateSet(System.Double,System.Double)">
<summary>
 set the internals of the qubit (if unentangled)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.StateSet(Microsoft.Research.Liquid.Bit)">
 <summary>
 Sets the state vector for this qubit to |0> or |1>, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
 <param name="b">The Bit value to set this qubit's state to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.StateSet(Microsoft.Research.Liquid.CVec)">
 <summary>
 Sets the state vector for this qubit, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
 <param name="v">The Complex vector to set this qubit's state to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ShowMag">
 <summary>
 Creates a string representation of this Qubit.
 The representation shows the probabilities of measuring this Qubit
 in the computational |0> and |1> states.
 <seealso cref="M:Microsoft.Research.Liquid.Qubit.ToString()"/>
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.Read(System.IO.BinaryReader,Microsoft.Research.Liquid.Ket)">
 <summary>
 Read a qubit from a binary stream
 </summary>
 <param name="br">Binary Reader</param>
 <param name="ket">State vector that qubit belongs to</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
<summary>
 set the internals of the qubit (if unentangled)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(System.Double,System.Double,System.Double,System.Double)">
<summary>
 set the internals of the qubit (if unentangled)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(System.Double,System.Double)">
<summary>
 set the internals of the qubit (if unentangled)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(Microsoft.Research.Liquid.Bit)">
 <summary>
 Reanimates this qubit and sets its state vector to |0> or |1>.
 Reanimation means that this qubit is treated as unmeasured and eligible
 for quantum operations.
 This method will raise an exception if the qubit is unmeasured or entangled.
 </summary>
 <param name="b">The Bit value to set this qubit's state to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(Microsoft.Research.Liquid.CVec)">
 <summary>
 Reanimates this qubit and sets its state vector.
 Reanimation means that this qubit is treated as unmeasured and eligible
 for quantum operations.
 This method will raise an exception if the qubit is unmeasured or entangled.
 </summary>
 <param name="v">The Complex vector to set this qubit's state to.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dump this qubit's state.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Qubit.#ctor(System.Int32,Microsoft.Research.Liquid.Ket)">
 <summary>
 Definition of a qubit
 </summary>
 <param name="id">Wire index</param>
 <param name="ket">State vector that this qubit belongs to (see Types.Ket class)</param>
</member>
<member name="T:Microsoft.Research.Liquid.Qubit">
 <summary>
 Represents a quantum bit.
 New Qubits are created using the 
 <see cref="T:Microsoft.Research.Liquid.Ket">Ket</see> Add methods.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Bit.v">
 <summary>
 The integer value of a measured qubit, either 0 or 1.
 Note that this property will throw an exception if the value is unknown.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Bit.ToString">
 <summary>
 Gets a string representation of this value.
 The string will be "Zero", "One", or "?".
 </summary>
 <returns>The string</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Bit.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps the measured value.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Bit">
 <summary>
 Represents the measured value, in the computational basis, of a qubit.
 </summary>
 <remarks>
 Possible values are:
 <ul>
 <li><b>Unknown</b>: The qubit has not been measured since it was initialized or since the
 last time it was reanimated.</li>
 <li><b>Zero</b>: The qubit was last measured as |0> in the computational basis and has not been
 reanimated since.</li>
 <li><b>One</b>: The qubit was last measured as |1> in the computational basis and has not been
 reanimated since.</li>
 </ul>
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.KetMode.InRun">
<summary>
 Are we in Run mode?
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.KetMode.InGate">
<summary>
 Are we in gate mode?
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.KetMode.InCirc">
<summary>
 Are we in Circuit mode?
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.KetMode">
 <summary>
 Current mode for Ket operations (used internally)
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.DrwAST.Parse(System.String)">
 <summary>
 Parse a Drw command string and split into an AST
 </summary>
 <param name="cmds">String of commands to render</param>
 <returns>DrwAst list list (command list with each piece)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.DrwAST.Morph(System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,System.String})">
 <summary>
 Morph one drawing into another (changing strings) for Modify() gates
 </summary>
 <param name="txt">Drawing string</param>
 <param name="f">Morphing function</param>
 <returns>New drawing (e.g., add a ^\\dagger to names)</returns>
</member>
<member name="P:Microsoft.Research.Liquid.KrausOp.mat">
<summary>
 Kraus operator matrix
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.KrausOp.tag">
<summary>
 Name to use for POVM application (usually a user provided index)
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.KrausOp">
 <summary>
 Entries for Kraus operators in Channel Gate type
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Render.Run(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Collections.FSharpList{System.String}[0:,0:],System.Boolean[0:,0:],System.Int32,System.Int32)">
 <summary>
  Circuit independent rendering level
 </summary>
 <param name="file">File to create</param>
 <param name="typ">Type of output</param>
 <param name="split">Percentage to split</param>
 <param name="scale">Percentage to scale</param>
 <param name="layout">Circuit layout info</param>
 <param name="bins">Binary wire info</param>
 <param name="mxRow">Max rows</param>
 <param name="mxCol">Max columns</param>
</member>
<member name="M:Microsoft.Research.Liquid.TikZ.Render(System.String,Microsoft.FSharp.Collections.FSharpList{System.String}[0:,0:],System.Double,System.Double,System.Int32)">
 <summary>
 Render a circuit to a TeX file (requires LiquidTikZ.tex)
 </summary>
 <param name="file">Name of file to create</param>
 <param name="layout">2D layout of commands</param>
 <param name="split">Percent of circuit/line</param>
 <param name="scale">Percent of original scale</param>
 <param name="mxCol">Max Columns to use</param>
</member>
<member name="M:Microsoft.Research.Liquid.QCircuit.Render(System.String,Microsoft.FSharp.Collections.FSharpList{System.String}[0:,0:],System.Double,System.Double,System.Int32)">
 <summary>
 Render a circuit to a TeX file (requires QcircuitLiquid.tex)
 </summary>
 <param name="file">Name of file to create</param>
 <param name="layout">2D layout of commands</param>
 <param name="split">Percent of circuit/line</param>
 <param name="scale">Percent of original scale</param>
 <param name="mxCol">Max Columns to use</param>
</member>
<member name="M:Microsoft.Research.Liquid.SVG.Render(System.String,Microsoft.FSharp.Collections.FSharpList{System.String}[0:,0:],System.Double,System.Double,System.Int32)">
 <summary>
 Render a circuit to an SVG file
 </summary>
 <param name="file">Name of file to create</param>
 <param name="layout">2D layout of commands</param>
 <param name="split">Percent of circuit/line</param>
 <param name="scale">Percent of original scale</param>
 <param name="mxCol">Max Columns to use</param>
</member>
<member name="M:Microsoft.Research.Liquid.SVG.Draw(System.Int32)">
 <summary>
  Draw 1 staff
 </summary>
 <param name="staff">Staff number (0 based)</param>
</member>
<member name="M:Microsoft.Research.Liquid.SVG.Close">
<summary>
 Close out an SVG drawing
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Circuit.NotEmpty">
 <summary>
 Is this Circuit element not the "Empty" circuit.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Wires">
 <summary>
 Gets the list of wires (qubit IDs) touched by this circuit.
 </summary>
 <returns>A list of the wires used</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.ToString">
 <summary>
 Returns a string representing the current circuit element. 
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Run(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Runs this Circuit.
 The state of the Ket containing the passed-in qubits will be modified.
 </summary>
 <param name="qs">The list of Qubits to operate on.
 These must correspond to the qubits the circuit was compiled with;
 that is, they must have the same qubit IDs as those.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Reverse">
 <summary>
 Reverses this circuit, which must contain only unitary gates.
 In addition, bottom-level gates are replaced by their adjoints.
 This method will raise an exception if this circuit contains a non-unitary gate.
 </summary>
 <returns>The resulting reversed circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.RenderHT(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>
 Renders a circuit to both svg, for HTML, and tikz, for TeX.
 <seealso cref="M:Microsoft.Research.Liquid.Circuit.Render(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})"/>
 </summary>
 <remarks>
 Detail is 0 for least, increasing wrap levels by each increment.
 That is, at level 0 only the top-level gate of a Wrap is displayed;
 at level 1, the top-level circuit that implements the Wrap is displayed;
 at l;evel 2, the top-level circuit is displayed with its Wrap gates also
 unwrapped once; etc.
 </remarks>
 <param name="file">The base name of the files to create.
 Appropriate extensions will be added for the created files: ".htm" for the
 SVG rendering, and ".tex" for the TikZ rendering.</param>
 <param name="detail">An option specifying how many levels of Wrap to unwrap.
 The default is 999.</param>
 <param name="split">An option specifying what percentage of the total gates should go into each figure,
 if the circuit won't fit into a single figure.
 The default value varies with the figure size.</param>
 <param name="scale">An option specifying a scaling percentage for the rendering, with 100.0 being full size.
 The default value varies with the figure size.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Render(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>
 Renders this circuit to a file.
 </summary>
 <remarks>
 Detail is 0 for least, increasing wrap levels by each increment.
 That is, at level 0 only the top-level gate of a Wrap is displayed;
 at level 1, the top-level circuit that implements the Wrap is displayed;
 at l;evel 2, the top-level circuit is displayed with its Wrap gates also
 unwrapped once; etc.
 </remarks>
 <param name="file">The full name of the file to create, including the extension.</param>
 <param name="typ">The optional format for the rendered graphics. Possible values are:
 <ul>
 <li><b>"qc"</b>: QCircuit Liquid format</li>
 <li><b>"tikz"</b>: TikZ Liquid format for TeX and LaTeX</li>
 <li><b>"svg"</b>: Vector graphics format for HTML</li>
 </ul>
 The default is "svg".</param>
 <param name="detail">An option specifying how many levels of Wrap to unwrap.
 The default is 999.</param>
 <param name="split">An option specifying what percentage of the total gates should go into each figure,
 if the circuit won't fit into a single figure.
 The default value varies with the figure size.</param>
 <param name="scale">An option specifying a scaling percentage for the rendering, with 100.0 being full size.
 The default value varies with the figure size.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.RemoveRedund">
 <summary>
 Creates a new circuit logically equivalent to this circuit, but with redundant gates removed.
 For instance, if this routine found a sequence of two X gates in succession on the same qubit,
 it would remove both of them from the result.
 </summary>
 <returns>The new, trimmed circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.NestHam">
 <summary>
 Nest Hamiltonians after removing redundancies (expects specific structure and only PQRS)
 </summary>
 <returns>New circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">
 <summary>
 Converts this circuit into a single unitary gate, implemented by a single matrix.
 This allows maximum optimization of circuit execution.
 <para>
 This circuit must be completely unitary to be converted into a single matrix.
 If it is not, an exception will be raised by this method.
 </para>
 </summary>
 <param name="gp">Optional grow parameters.
 The default is to use all of the GrowPars defaults.
 See the <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> type for details.</param>
 <returns>The new single-gate Circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Grow circuit into large gates.
 </summary>
 <param name="k">Ket vector (only used to check ChkAbort() if long running)</param>
 <param name="maxWires">Max wires in a grown gate (optional=99)</param>
 <param name="verbose">0=Don't report progress, 1=final, 2=all (optional=2)</param>
 <param name="allowDense">ignore density (optional=false)</param>
 <returns>New optimized Circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">
 <summary>
 Creates an equivalent circuit to this circuit by aggregating existing unitary gates into larger unitary gates.
 The new circuit will execute faster because it has fewer matrix applications required.
 </summary>
 <param name="k">A Ket this Circuit could be run with.</param>
 <param name="gp">Optional grow parameters.
 The default is to use all of the GrowPars defaults.
 See the <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> type for details.</param>
 <returns>New optimized Circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Grow(Microsoft.Research.Liquid.Ket,Microsoft.Research.Liquid.GrowPars)">
 <summary>
 Creates an optimized "grown" version of this Circuit.
 The type and limits of the conversion are specified in the grow parameter.
 </summary>
 <param name="k">A Ket this Circuit could be run with.</param>
 <param name="gp">The grow parameters to use.
 See the <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> type for details.</param>
 <returns>A new, optimized Circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.GateCount(Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Gate,System.Boolean}})">
 <summary>
 Gets the count of gates in circuit.
 Note that pure label gates -- that is, gates of type String -- are never counted.
 </summary>
 <param name="doParallel">An option to only count the longest sub-circuit of
 a parallel component, rather than adding all gates in all components.
 This is useful when computing gate depth.
 The default is false, which counts all gates, summing over parallel sub-circuits.</param>
 <param name="gMatch">An optional function to filter which gates should be counted.
 If a match function is provided, only gates that return true are included in the count.
 The default is to count all non-String gates.</param>
 <returns>The count of low-level gates in the circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Fold(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Rewrites this circuit by identifying opportunities for parallelism and turning Seq elements
 into Par elements where possible.
 This makes for a better rendering.
 </summary>
 <param name="agressive">An option to fold as much as possible by decomposing this circuit
 into basic gates before folding. 
 The default is to not decompose Wrap gates and other aggregates before folding.</param>
 <returns>The new folded circuit</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Flatten(Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Flattens this entire circuit into a straight sequence of basic gates
 Warning: This is normally only used internally (use GrowSingle)
 </summary>
 <param name="doingHam">Doing a Hamiltonian? Leave markers (optional=false)</param>
 <param name="forward">Return in forward order? (optional=false)</param>
 <param name="multiple">Return multiple results in the array? (optional=false)</param>
 <param name="verbose">Level 0-2? (optional=2)</param>
 <returns>IsUnitary,reference to flattened circuit (in desired order)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.FindIds(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Find Ids below this point and the time needed to execute the circuit (internal)
 </summary>
 <param name="detail">What level of detail for when we hit a "Wrap" gate</param>
 <param name="cntEmpty">An option allowing Empty gates to be counted like Native
 The default is false, which is to not count Empty gates as Native.</param>
 <returns>Set of ids,total time to execute</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Final(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Circuit})">
 <summary>
 Helper routine for termintating circuit build (used internally)
 </summary>
 <param name="cs">Current circuit list in reverse order</param>
 <returns>[] if "Empty" or reversed list</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps this circuit recursively to the console and/or log.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.Compile(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Compiles a function implemented as a sequence of gate function calls into a Circuit.
 </summary>
 <param name="f">The gate function to compile.</param>
 <param name="qs">The qubits the new Circuit will operate on.</param>
 <returns>A new Circuit that represents the function calls</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Circuit.AddControl(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Gate})">
 <summary>
 Adds a control to all non-skipped gates.
 All wires are shifted down one for the control, which becomes the top (zero) wire.
 </summary>
 <param name="skips">A list of Gates to leave un-controlled</param>
</member>
<member name="T:Microsoft.Research.Liquid.Circuit">
 <summary>
 The circuit representation of an operation in a quantum algorithm.
 Circuits are generally created using 
 <see cref="M:Microsoft.Research.Liquid.Circuit.Compile(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">Circuit.Compile</see>.
 </summary>
 <remarks>
 The possible types of circuits are:
 <ul>
 <li><b>Seq</b>: A list of sub-circuits executed equentially.</li>
 <li><b>Par</b>: A list of sub-circuits executed in parallel.</li>
 <li><b>Apply</b>: Application of a single gate.</li>
 <li><b>Ext</b>: Application of a single gate that extends a parent, such as an adjoint or control.
 This type of circuit is created from a Modify gate.</li>
 <li><b>BitCon</b>: Application of a classically-controlled (BCOp) gate.</li>
 <li><b>Wrap</b>: A sub-circuit wrapped into a single gate for more concise rendering.</li>
 <li><b>Empty</b>: A circuit that does nothing.</li>
 </ul>
 </remarks>
</member>
<member name="T:Microsoft.Research.Liquid.FlatCs">
<summary>
 Used internally
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.CacheDisable(System.Boolean)">
 <summary>
 Whether or not the gate cache is disabled.
 The cache is used if this property is false.
 The cache should be disabled if gates are being built in parallel.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.User">
 <summary>
 The user info associated with this gate, if any.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Qubits">
 <summary>
 The arity of this gate; that is, the number of qubits the gate operates on.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Parent">
 <summary>
 This gate's parent, if any. 
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Op">
 <summary>
 This gate's operation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Name">
 <summary>
 The name of this gate.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Mat">
 <summary>
 The unitary matrix for this gate.
 If the gate is not defined by a single unitary, this will be a 0x0 matrix.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Kraus">
 <summary>
 The Kraus operator matrix list for this gate (if op type is Channel).
 If the gate is not a channel, this will be an empty list.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Help">
 <summary>
 The help string for this gate.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Dummy">
<summary>
 Dummy gate for communications operations
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Draw">
 <summary>
 The drawing instructions for this gate.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.CacheDisable">
 <summary>
 Whether or not the gate cache is disabled.
 The cache is used if this property is false.
 The cache should be disabled if gates are being built in parallel.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Gate.Arity">
<summary>
 Get arity of the gate (based on Qubits or Mat/Kraus size).
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.ToString">
 <summary>
 Returns a string representation of this gate, based on the gate's name,
 help string, and type.
 </summary>
 <returns>The string representation</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.ShowMem(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Circuit}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Outputs memory and garbage collection statistics to the log and console.
 </summary>
 <param name="seconds">A minimum interval between reports.
 If a report was displayed within more recently, then no new report is displayed.</param>
 <param name="f">A function that returns a string to output as a prefix to the report.</param>
 <param name="cs">An optional list of Circuits to analyze.
 The count of Circuits in the list is reported.
 If the "deep" parameter is true, then the total count of gates in these Circuits is also reported.
 The default is an empty list, which displays counts of 0.</param>
 <param name="deep">An option indicating whether or not to count the gates in the list of Circuits.
 The default is false, which indicates that the gates should not be counted and will be reported as 0.</param>
 <param name="collect">An option indicating whether to force a garbage collection.
 The default is false, to not force a collection.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.ShowMem(System.Int32,System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Circuit}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Outputs memory and garbage collection statistics to the log and console.
 </summary>
 <param name="seconds">A minimum interval between reports.
 If a report was displayed within more recently, then no new report is displayed.</param>
 <param name="str">A string to output as a prefix to the report.</param>
 <param name="cs">An optional list of Circuits to analyze.
 The count of Circuits in the list is reported.
 If the "deep" parameter is true, then the total count of gates in these Circuits is also reported.
 The default is an empty list, which displays counts of 0.</param>
 <param name="deep">An option indicating whether or not to count the gates in the list of Circuits.
 The default is false, which indicates that the gates should not be counted and will be reported as 0.</param>
 <param name="collect">An option indicating whether to force a garbage collection.
 The default is false, to not force a collection.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.Run(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Run this gate.
 The details depend on the current value of 
 <see cref="P:Microsoft.Research.Liquid.Ket.Mode(Microsoft.Research.Liquid.KetMode)">Ket.Mode</see>:
 <ul>
 <li><b>RunMode</b>: Apply this gate operation to the supplied qubits.</li>
 <li><b>GateMode</b>: Stores this gate definition into the current Ket.
 This is for internal use.</li>
 <li><b>CircMode</b>: Compiles this gate into a Circuit.
 This is for internal use.</li>
 </ul>
 </summary>
 <param name="qs">The Qubits for this gate to operate on.
 They are also used to identify the current Ket.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.OptimizeKraus(Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Gate},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Optimze a Channel gate with Kraus operators (checks correctness and orders by magnitude)
 </summary>
 <param name="g2">Gate to append to make more complex channels (optional=None)</param>
 <param name="name">New name for the gate (optional=K####)</param>
 <param name="idMult">If appending, how much to multiply the parent gate IDs by (optional=count of appended)</param>
 <param name="povm">Tag to use as POVM symbol for the new gate (optional="POVM")</param>
 <returns>New Gate Function</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.NewMat(Microsoft.Research.Liquid.CSMat)">
 <summary>
 Makes a new gate based on this gate but with new unitary matrix.
 </summary>
 <param name="mat">The unitary matrix for the new gate.</param>
 <returns>The new gate</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.GetGate(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Gets the definition of a gate from a gate function.
 This is usually used to discover "Parent".
 </summary>
 <param name="f">Gate function we want the Gate for</param>
 <param name="qs">Qubits to operate on</param>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.GetCirc(System.String,Microsoft.Research.Liquid.KetMode)">
 <summary>
 Get a circuit from a KetMode of CircMode (used internally)
 </summary>
 <param name="tag">Er` tag to output</param>
 <param name="mode">KetMode that hold circuit</param>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.FreeMem(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Forces a garbage collection if we are too close to physical memory size.
 The collection includes both releasing temporary memory used by Liquid and a .NET garbage collection.
 </summary>
 <param name="seconds">Optional minimum number of seconds between forced collections.
 If a collection was forced more recently than this, then a collection will not be triggered.
 The default is 60.</param>
 <param name="pcnt">Optional threshold percentage of physical memory in use
 to trigger a collection. The default is 80%.</param>
 <param name="str">An optional string tag to display with memory statistics, 
 if a collection was triggered.
 The default is null, which will cause statistics to not be logged.</param>
 <returns>The percentage of total system memory in use after the routine is done,
 whether or not a collection was triggered.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.Equals(Microsoft.Research.Liquid.Gate)">
 <summary>
 Tests equality to another Gate.
 Gates are considered equal if their name, arity, operation, and parent gate
 are the same.
 </summary>
 <param name="g2">The gate to test against.</param>
 <returns>true if the two Gates are equal, false otherwise.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.Embed">
 <summary>
 Embed gate from one circuit into a larger one (for now, just change lstick to ustick)
 </summary>
 <returns>Embedded gate</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps the full gate information to the consol and/or log.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.CacheStats">
 <summary>
 Gets gate cache statistics.
 </summary>
 <returns>A tuple of the cache hit count and cache miss count.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.CacheClear">
 <summary>
 Clears out the gate cache.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.Build(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.Research.Liquid.Gate})">
 <summary>
 Gets the definition of a gate, using the cache.
 If the gate is already in the cache, the cached definition is returned.
 Otherwise, a new gate will be created, added to the cache, and returned.
 </summary>
 <param name="key">The uniqur key to use to identify this gate in the cache.
 This may be more than just the gate name; for instance, for a rotation gate,
 the cache key must include the rotation angle as well as just "Rz".
 If the key is null or "", the cache will be bypassed.</param>
 <param name="gen">A function that may be used to create a definition for the
 gate if it is not already in the cache.</param>
 <returns>The gate associated with the provided key</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.AddControl(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates a new gate by adding one or more control qubits to an existing unitary gate.
 </summary>
 <param name="count">The optional number of control qubits to add.
 The default is a single control.</param>
 <param name="noCache">An option to prevent caching of the new gate.
 The default is false, which means that the new gate should be cached.
 The key for the cache is a sequence of capital Cs, one for each control
 qubit added, followed by an underscore, '_', and then the name of the base gate.</param>
 <returns>The new controlled gate</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Gate.#ctor(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.CSMat},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GateOp},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Gate}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.Object}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.KrausOp}})">
 <summary>
 Creates a new gate from scratch.
 </summary>
 <param name="Name">The optional name of the gate we're creating.
 The default is "".</param>
 <param name="Qubits">The optional arity of gate; that is, the number of qubits this gate operates on. 
 If a matrix for the gate is provided using the Mat parameter, then the arity is deduced from the
 dimensions of the matrix.
 The default value is 0.
 </param>
 <param name="Mat">An optional sparse unitary matrix that implements the gate.
 This parameter is only used for gates that implement a unitary operation.
 The default is no unitary.</param>
 <param name="Draw">An optional string to use to render the gate.
 This should be a <see href="http://physics.unm.edu/CQuIC//Qcircuit/">Q-Circuit</see>
 drawing string, if provided.
 The default is "", which means that the gate doesn't show up when rendered.</param>
 <param name="Help">An optional help string for the gate.
 The default is no help string, "".</param>
 <param name="Op">The optional gate operation to perform.
 The default is Normal, which is a unitary gate defined by a matrix.</param>
 <param name="Parent">The optional parent gate, if required by the gate operation type.
 The default is None.</param>
 <param name="User">An optional user-defined field.</param>
 <param name="Kraus">An optional list of Kraus tags and matrices for Channels.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Gate">
 <summary>
 A quantum gate.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Verbose">
 <summary>
 The logging verbosity level.
 Possible values are:
 <ul>
 <li><b>0</b>: No grow logging</li>
 <li><b>1</b>: Final circuit logging</li>
 <li><b>2</b>: Full detailed logging</li>
 </ul>
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Skip">
 <summary>
 Count of initial qubits to skip (because they are used for phase estimation) in 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">Circuit.GrowSingle</see>.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Single">
 <summary>
 If true, build a single unitary; if false, grow gates into a denser circuit.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Redund">
 <summary>
 For Fermion circuits, whether to ignore (set to zero) portions of the resulting unitary
 that don't satisfy the <see cref="P:Microsoft.Research.Liquid.GrowPars.ECnt">electron count</see>, 
 <see cref="P:Microsoft.Research.Liquid.GrowPars.Parity">parity check</see>, or 
 <see cref="P:Microsoft.Research.Liquid.GrowPars.Diff">net spin</see> constraints.
 See the Users' Guide for details.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Parity">
 <summary>
 For Fermion circuits, whether to enforce conservation of angular momentum via parity.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.OCnt">
 <summary>
 For Fermion circuits, the number of electron states. 
 In chemical simulations, this is the spin orbital count.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.MaxWires">
 <summary>
 The maximum wire count for a single grown gate generated by 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Half">
 <summary>
 For Fermion circuits, are the qubits ordered so that the first half are the spin-up states?
 The alternative is for qubits to represent alternating spin-up andn spin-down states.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.ECnt">
 <summary>
 For Fermion circuits, the valid total electron count (total number of occupied states).
 A value of 0 means that any number of electrons is valid.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Diff">
 <summary>
 For Fermion circuits, a list of allowed differences between spin-up and spin-down counts.
 Effectively, this list constrains the possible values of the total net spin of valid configurations.
 An empty list, [], means to allow any difference.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.Coalesce">
 <summary>
 For Hamiltonian circuits, a tuple of a scale value and 
 a flag specifying whether or not to keep rotation gates around small angles.
 The scale value is used if the flag is false.
 See the Users' Guide for details.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.GrowPars.AllowDense">
 <summary>
 If true, allow dense matrices to be generated by
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.GrowPars.VerboseSet(System.Int32)">
 <summary>
 Creates a new GrowPars with a different verbosity setting.
 <sealso cref="P:Microsoft.Research.Liquid.GrowPars.Verbosity"/>
 </summary>
 <param name="vNew">The new verbosity level</param>
 <returns>The new GrowPars instance</returns>
</member>
<member name="M:Microsoft.Research.Liquid.GrowPars.ToString">
 <summary>
 Gets a string representation of this circuit grow parameter set.
 </summary>
 <returns>The string</returns>
</member>
<member name="M:Microsoft.Research.Liquid.GrowPars.PhysicallyLegal(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Generates a dictionary of physically legal rows or columns for this GrowPars.
 </summary>
 <param name="numQubits">The total qubit count, including skpped phase estimation qubits and trailing ancilla.</param>
 <param name="drop">An option indicating whether to drop the low half of the addresses, for optimized dense translations.
 The default is false.</param>
 <returns>Dictionaries of legal mappings (dicD=sparse,dicS=dense,up,down)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.GrowPars.#ctor(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Double,System.Boolean}})">
 <summary>
 Creates an instance with appropriate parameters for 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">Circuit.GrowSingle</see>,
 which generates a single unitary operation equivalent to an existing Circuit.
 </summary>
 <param name="half">
 The value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Half">Half</see>.
 This parameter is required.
 </param>
 <param name="eCnt">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.ECnt">ECnt</see>.
 The default is 0.
 </param>
 <param name="oCnt">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.OCnt">OCnt</see>.
 The default is 0.
 </param>
 <param name="skip">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Skip">Skip</see>.
 The default is 0.
 </param>
 <param name="diff">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.ECnt">ECnt</see>.
 The default is an empty list, [].
 </param>
 <param name="verbose">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Verbose">Verbose</see>.
 The default is 1.
 </param>
 <param name="parity">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Parity">Parity</see>.
 The default is false.
 </param>
 <param name="redund">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Redund">Redund</see>.
 The default is 0.
 </param>
 <param name="coalesce">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Coalesce">Coalesce</see>.
 The default is (0.0, false).
 </param>
</member>
<member name="M:Microsoft.Research.Liquid.GrowPars.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Creates an instance with appropriate parameters for 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>,
 which generates a denser circuit equivalent to an existing Circuit.
 </summary>
 <param name="maxWires">An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.MaxWires">MaxWires</see>.
 The default is 11.</param>
 <param name="verbose">An optional value for
 <see cref="P:Microsoft.Research.Liquid.GrowPars.Verbosity">Verbosity</see>. 
 The default is 0.</param>
 <param name="allowDense">An optional value for
 <see cref="P:Microsoft.Research.Liquid.GrowPars.AllowDense">AllowDense</see>. 
 The default is false.</param>
</member>
<member name="T:Microsoft.Research.Liquid.GrowPars">
 <summary>
 Parameters that control circuit growth.
 See <see cref="M:Microsoft.Research.Liquid.Circuit.Grow(Microsoft.Research.Liquid.Ket,Microsoft.Research.Liquid.GrowPars)">Circuit.Grow</see>,
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>,
 and <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">Circuit.GrowSingle</see>.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.GateOp.ToString">
 <summary>
 Creates a string representation of this gate operation type.
 </summary>
 <returns>The string</returns>
</member>
<member name="T:Microsoft.Research.Liquid.GateOp">
 <summary>
 Gate operation type.
 This is used in <see cref="T:Microsoft.Research.Liquid.Gate">Gate</see> definitions.
 </summary>
 <remarks>
 The possible values for this type are:
 <ul>
 <li><b>Normal</b>: Implements a unitary operation and is defined by a matrix.</li>
 <li><b>Measure</b>: Measures a single qubit or the joint parity of a groupt of qubits.</li>
 <li><b>Channel(sym)</b>: Selects a Kraus operator to run (sym is a symbol to store the selected index for POVMs)</li>
 <li><b>Reset(b)</b>: Reanimates a measured qubit to the Bit value b. If b is Unknown, then the
 qubit is reanimated to its last measured value.</li>
 <li><b>String</b>: Puts a label in a diagram</li>
 <li><b>Modify(n)</b>: Modifies a parent gate. The modified gate takes n more wires (input qubits)
 than the parent gate.</li>
 <li><b>BCOp(n,f)</b>: Implements a classically-controlled gate.
 There are two cases: if n is greater than zero, then the control is logically based on the measured
 values of n qubits.
 If n is equal to zero, then the control is logically based on the result of one or more
 joint parity measurements.
 In either case, f is the function that determines whether or not to execute the parent gate.</li>
 <li><b>WrapOp(f)</b>: Wraps multiple gates into one logical gate.
 This is used for multi-level circuit drawing.</li>
 <li><b>WrapHam(pqrs,f)</b>: Wraps multiple gates into a single Hamiltonian term. 
 This is used for <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">GrowSingle.</see></li>
 </ul>
 </remarks>
</member>
<member name="F:Microsoft.Research.Liquid.NoisyMats.Injected@">
 <summary>
 Stats for injected noise gates
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoisyMats.Injected(System.Int32)">
 <summary>
 Stats for injected noise gates
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoisyMats.Injected">
 <summary>
 Stats for injected noise gates
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.NoisyMats.GenRot(System.Double,Microsoft.Research.Liquid.CSMat)">
 <summary>
 Generates a Pauli-based rotation matrix for an arbitrary angle.
 </summary>
 <param name="theta">The rotation angle.</param>
 <param name="mParent">The base matrix for the rotation.
 This must be an idempotent Hermitian matrix.</param>
 <returns>A rotation matrix, exp(i*theta/2*mParent).</returns>
</member>
<member name="M:Microsoft.Research.Liquid.NoisyMats.BitMatrix(System.Int32)">
 <summary>
 Compute the matrix for a given bit of PE
 </summary>
 <param name="bitNum">Highest bit is 0 (passed in during creation)</param>
</member>
<member name="M:Microsoft.Research.Liquid.NoisyMats.#ctor(System.Double,Microsoft.Research.Liquid.CMat,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CMat})">
 <summary>
 Creates a generator of noisy matrices for exponentiated phase estimation.
 </summary>
 <param name="errProb">This is expected to be sqrt(depolarizing noise)</param>
 <param name="mat0">Matrix for bit 0</param>
 <param name="gateCnt">Number of gates represented by mat0</param>
 <param name="qs">Qubits that matrix represents</param>
 <param name="s2d">Sparse to dense matrix converter</param>
</member>
<member name="T:Microsoft.Research.Liquid.NoisyMats">
 <summary>
 Utility class for computing a Pauli rotation matrix.
 This is used to run quantum chemistry circuits with noise injected.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.TraceWrap(System.Boolean)">
 <summary>
 Whether or not to trace wrap gates to the log as they're executed.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.TraceNoise(System.Boolean)">
 <summary>
 Whether or not to trace noise to the log as it's inserted.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.NoNoise(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 The list of noiseless gates, by name.
 A name may end with "*" to indicate a wildcard.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.LogGates(System.Boolean)">
 <summary>
 Whether or not to log gate execution to noise statistics during Run().
 Gate execution log entires will be marked with detail="!".
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.Idle(Microsoft.Research.Liquid.Gate)">
 <summary>
 (Set only)
 The idle gate.
 By default, I (the identity) is the idle gate.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.ECgates(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 The list of wrap gates that are part of error-correcting circuits, by name.
 A name may end with "*" to indicate a wildcard.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.DampProbs(System.Double)">
 <summary>
 (Set only)
 The amplitude damping probability for all qubits.
 Use <see cref="P:Microsoft.Research.Liquid.Noise.DampProb(System.Int32,System.Double)">DampProb</see>
 to get or set the amplitude damping probaility for a single qubit.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.DampProb(System.Int32,System.Double)">
 <summary>
 The probability of amplitude-damping noise on a qubit.
 This allows different qubits to have different amplitude damping probabilities.
 </summary>
 <param name="id">The ID of the qubit</param>
 <param name="prob">The amplitude damping noise probability.</param>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.TraceWrap">
 <summary>
 Whether or not to trace wrap gates to the log as they're executed.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.TraceNoise">
 <summary>
 Whether or not to trace noise to the log as it's inserted.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.Stats">
 <summary>
 The error statistics from the last run.
 Statistics are kept in reverse time order.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.NoNoise">
 <summary>
 The list of noiseless gates, by name.
 A name may end with "*" to indicate a wildcard.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.Models">
 <summary>
 The noise models from last run.
 This provides access to the detailed statistics.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.LogGates">
 <summary>
 Whether or not to log gate execution to noise statistics during Run().
 Gate execution log entires will be marked with detail="!".
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.Idle">
 <summary>
 (Set only)
 The idle gate.
 By default, I (the identity) is the idle gate.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.ECgates">
 <summary>
 The list of wrap gates that are part of error-correcting circuits, by name.
 A name may end with "*" to indicate a wildcard.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.DampProbs">
 <summary>
 (Set only)
 The amplitude damping probability for all qubits.
 Use <see cref="P:Microsoft.Research.Liquid.Noise.DampProb(System.Int32,System.Double)">DampProb</see>
 to get or set the amplitude damping probaility for a single qubit.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Noise.DampProb(System.Int32)">
 <summary>
 The probability of amplitude-damping noise on a qubit.
 This allows different qubits to have different amplitude damping probabilities.
 </summary>
 <param name="id">The ID of the qubit</param>
 <param name="prob">The amplitude damping noise probability.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Noise.Run(Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Ket})">
 <summary>
 Runs a circuit with this noise model.
 </summary>
 <param name="ket2">An optional state vector to use to re-initialize execution.
 If provided, this Ket is used for the run and all times and statistics are reset.
 If not provided, then execution continues from the state after the last Run.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Noise.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Dumps noise statistics from the last run.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
 <param name="doStats">An option to dump full statistics.
 The default is false, in which case summary statistics per gate pattern are displayed.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Noise.DefaultNoise(System.Double)">
 <summary>
 Creates a default noise model.
 The new noise model has depolarizing noise on all qubits,
 and all gates have unit expected duration.
 </summary>
 <param name="prob">The probability of depolarizing noise occuring per unit of time.</param>
 <returns>The new noise model.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Noise.#ctor(Microsoft.Research.Liquid.Circuit,Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.NoiseModel})">
 <summary>
 Creates a new Noise instance.
 </summary>
 <param name="circ">The circuit to apply noise to.</param>
 <param name="ket">The Ket to use for noise model.</param>
 <param name="models">A list of noise models to use, in decreasing precedence order.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Noise">
 <summary>A complete noise model for a specific circuit.</summary>
</member>
<member name="T:Microsoft.Research.Liquid.NoiseStats">
 <summary>A list of accumulated noise statistics.</summary>
</member>
<member name="T:Microsoft.Research.Liquid.NoiseModels">
 <summary>A list of noise models, kept in decending precedence order.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseStat.detail">
 <summary>User-defined noise details from the noise function output.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseStat.ecGate">
 <summary>Whether or not thie was flagged as an error correcting gate.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseStat.model">
 <summary>The noise model that was applied.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseStat.qs">
 <summary>The qubits that noise was applied to.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseStat.dur">
 <summary>The duration of the noise applicationm.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseStat.time">
 <summary>When noise was applied during the simulated execution.</summary>
</member>
<member name="M:Microsoft.Research.Liquid.NoiseStat.ToString">
 <summary>
 Returns a string representation of this noise statistic.
 </summary>
 <returns>The string</returns>
</member>
<member name="T:Microsoft.Research.Liquid.NoiseStat">
 <summary>Statistics tracked for each time that noise is applied.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseModel.ecEvents">
 <summary>Accumulated noise statistics for error-correcting gates.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseModel.gateEvents">
 <summary>Accumulated noise statistics for normal gates.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseModel.func">
 <summary>The noise function to execute.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseModel.time">
 <summary>The expected duration of the gate. By convention, an idle gate takes 1.0 units.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseModel.maxQs">
 <summary>The maximum number of qubits to apply noise to.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseModel.gate">
 <summary>The name of the gate that this noise model applies to. 
 The name may end with an asterisk, '*', to indicate a wildcard match.</summary>
</member>
<member name="M:Microsoft.Research.Liquid.NoiseModel.Default(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{System.String}}}}}})">
 <summary>Creates a default noise model that will apply to all gates.</summary>
 <param name="modelFunc">The noise function to apply.</param>
 <returns>A noise model that will apply the given function to all gates,
 to a single qubit, and initialized with zero statistics.</returns>
</member>
<member name="T:Microsoft.Research.Liquid.NoiseModel">
 <summary>A noise model for a particular type of gate (or set of gates).</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseEvents.events">
 <summary>The number of noise events</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseEvents.applied">
 <summary>The number of times noise has been applied</summary>
</member>
<member name="P:Microsoft.Research.Liquid.NoiseEvents.count">
 <summary>The number of times the model has been executed</summary>
</member>
<member name="M:Microsoft.Research.Liquid.NoiseEvents.Reset">
 <summary>Resets all counters back to 0.</summary>
</member>
<member name="M:Microsoft.Research.Liquid.NoiseEvents.Default">
 <summary>Creates a new instance with all counts initialized to 0.</summary>
 <returns>The new instance.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.NoiseEvents.Accum(Microsoft.Research.Liquid.NoiseEvents)">
 <summary>Increments this instance with counts from another instance.</summary>
 <param name="y">The instance containing counts to add to this instance's counts.</param>
</member>
<member name="T:Microsoft.Research.Liquid.NoiseEvents">
 <summary>
 Noise statistics that are tracked for normal and error-correcting gates.
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.NoiseFunc">
 <summary>
 Function type for implementing noise models.
 <para>
 Parameters are:
 </para>
 <ul>
 <li>tim:  The actual time spent in this gate (may be multiple executions)</li>
 <li>dur:  The time spent to execute this gate once</li>
 <li>qs:   The list of qubits operated on by the gate</li>
 </ul>
 The function should return a list of noise applied, as tuples of the qubit that had noise applied
 and optional detail information.
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.LiquidArgs">
<summary>
 Parser result
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.headNode">
<summary>
 Working directory for HPC
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.workDir">
<summary>
 Job template to use
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.template">
<summary>
 Max nodes to use for HPC
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.nodesMx">
<summary>
 Min nodes to use for HPC
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.nodesMn">
<summary>
 Commands to execute (re-used if runs is smaller)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.cmds">
<summary>
 Number of runs to execute
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.count">
<summary>
 Name of run to do
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.doName">
<summary>
 Machines to run services on
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.hosts">
<summary>
 Network accessible location of exec for service
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.EnsembleInfo.Default">
<summary>
 Head node of cluster
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.EnsembleInfo">
 <summary>
 Ensemble information
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Hamiltonian.prefixInfo(System.String)">
<summary>Get or set the output prefix associated with this Hamiltonian</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}})">
 <summary>
 The decoherence model for this Hamiltonian.
 </summary>
 <remarks>
 A decoherence model is a list of gates and a decoherence probability for each gate.
 Gates that do not appear have a zero decoherence probability.
 Note that gates appearing in this list must be fully resolved; they may have no parameters
 other then the list of qubits.
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.Hamiltonian.Ket(Microsoft.Research.Liquid.Ket)">
<summary>Gets the Ket vector associated with this Hamiltonian</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Hamiltonian.prefixInfo">
<summary>Get or set the output prefix associated with this Hamiltonian</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel">
 <summary>
 The decoherence model for this Hamiltonian.
 </summary>
 <remarks>
 A decoherence model is a list of gates and a decoherence probability for each gate.
 Gates that do not appear have a zero decoherence probability.
 Note that gates appearing in this list must be fully resolved; they may have no parameters
 other then the list of qubits.
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.Hamiltonian.Ket">
<summary>Gets the Ket vector associated with this Hamiltonian</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Hamiltonian.Coalesce(System.Int32,Microsoft.FSharp.Core.FSharpRef{Microsoft.Research.Liquid.Circuit},Microsoft.Research.Liquid.GrowPars)">
 <summary>
 Coalesce trotter terms together with larger angles
 </summary>
 <param name="trotterN">Trotter number</param>
 <param name="circR">Circuit to start from (reference that's destroyed)</param>
 <param name="gp">Grow Params</param>
</member>
<member name="T:Microsoft.Research.Liquid.Hamiltonian">
 <summary>
 Base class for Hamiltonian dynamics simulators.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.trotterN(System.Int32)">
 <summary>
 The Trotter number.
 Note that setting this property will force a new circuit to be generated.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.time(System.Int32)">
 <summary>
 The current simulation time.
 Note that setting this property will force a new circuit to be generated.
 </summary>    
</member>
<member name="P:Microsoft.Research.Liquid.Spin.slideCirc(System.Int32)">
 <summary>
 Amount to slide the circuit from the beginning of the ket vector (for extra ancilla handling)
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.runMode(Microsoft.Research.Liquid.RunMode)">
 <summary>
 The run mode.
 Note that setting this property will force a new circuit to be generated.
 </summary>
 <remarks>
 Possibilities are Trotter1 (fully first-order); 
 Trotter1X (does X/2 on both sides, but fully first-order in other terms); 
 and Trotter2 (fully second-order). 
 The initial default value for new Hamiltonians is Trotter1.
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.trotterN">
 <summary>
 The Trotter number.
 Note that setting this property will force a new circuit to be generated.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.time">
 <summary>
 The current simulation time.
 Note that setting this property will force a new circuit to be generated.
 </summary>    
</member>
<member name="P:Microsoft.Research.Liquid.Spin.slideCirc">
 <summary>
 Amount to slide the circuit from the beginning of the ket vector (for extra ancilla handling)
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.runMode">
 <summary>
 The run mode.
 Note that setting this property will force a new circuit to be generated.
 </summary>
 <remarks>
 Possibilities are Trotter1 (fully first-order); 
 Trotter1X (does X/2 on both sides, but fully first-order in other terms); 
 and Trotter2 (fully second-order). 
 The initial default value for new Hamiltonians is Trotter1.
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.lastRawCirc">
 <summary>
 The last (ungrown) circuit that was run.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.lastAnneal">
 <summary>
 The last set of annealing coefficients that were applied.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Spin.currentCirc">
 <summary>
 The last (grown) circuit that was run.
 </summary>    
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Test(System.String,System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Double},System.Collections.Generic.Dictionary{System.Tuple{System.Int32,System.Int32},System.Double},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double,System.Double}},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}}})">
 <summary>
 Executes a set of simulation runs for a spin Hamiltonian.
 </summary>
 <param name="tag">The output label for logging.</param>
 <param name="repeats">The number of simulations to run.</param>
 <param name="trotter">The Trotter number to use.</param>
 <param name="hs">A Dictionary that maps a qubit id to that qubit's bias strength (Z term coefficient).</param>
 <param name="Js">A Dictionary that maps a pair of qubit id's to the pair's coupling strength (ZZ coefficient).</param>
 <param name="gammalambda">List of (time,gamma,lambda) tuples that define the annealing schedule.
 Each entry in the list is a tuple whose first entry is a time step and whose second entry is an 
 array of annealing values.
 Annealing values for time steps in between entries are computed by linearly interpolating
 between those for the previous and next entries.
 The list must be in ascneding order by time step.</param>
 <param name="res">The resolution of the simulation, in time steps. 
 Larger values may increase speed but will reduce the granularity of output.
 Note that this must evenly divide the final time in the annealing schedule.</param>
 <param name="runonce">An option to only run the simulation once and perform repeated 'virtual measurements'.
 The default is false, which means to run the simulation and measure each time.</param>
 <param name="decohereModel">An optional decoherence model to use for this simulation.
 See <see cref="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}})">Hamiltonian.decohereModel</see> for more information.
 The default is no decoherence.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Test(System.String,System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double[]}},System.Int32,Microsoft.Research.Liquid.Spin,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}}})">
 <summary>
 Executes a set of simulation runs for a spin Hamiltonian.
 </summary>
 <param name="tag">The output label for logging.</param>
 <param name="repeats">The number of simulations to run.</param>
 <param name="trotter">The Trotter number to use.</param>
 <param name="schedule">The annealing schedule to use.
 Each entry in the list is a tuple whose first entry is a time step and whose second entry is an 
 array of annealing values.
 Annealing values for time steps in between entries are computed by linearly interpolating
 between those for the previous and next entries.
 The list must be in ascneding order by time step.</param>
 <param name="res">The resolution of the simulation, in time steps. 
 Larger values may increase speed but will reduce the granularity of output.
 Note that this must evenly divide the final time in the annealing schedule.</param>
 <param name="spin">The actual Hamiltonian to be simulated.</param>
 <param name="runonce">An option to only run the simulation once and perform repeated 'virtual measurements'.
 The default is false, which means to run the simulation and measure each time.</param>
 <param name="decohereModel">An optional decoherence model to use for this simulation.
 See <see cref="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}})">Hamiltonian.decohereModel</see> for more information.
 The default is no decoherence.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Step(System.Double[],Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">
 <summary>
 Performs a single timestep of simulation.
 </summary>
 <param name="angles">The vector of annealing coefficients to be used in this step.</param>
 <param name="gp">Optional grow parameters for the resulting circuit.
 The default is GrowGates with maxWires of 11.
 See <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> for more details.</param>
 <returns>The number of decoherence events which occured during the step.
 Note that this will be zero unless a decoherence model has been set on this instance.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.SpinGlass">
 <summary>
 Test adiabatic evolution with a spin-glass problem
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Run(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double[]}},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">
 <summary>
 Runs the simulation.
 This is a highly optimized implementation.
 </summary>
 <param name="dt">The number of timesteps to run.</param>
 <param name="schedule">The annealing schedule to use.
 Each entry in the list is a tuple whose first entry is a time step and whose second entry is an 
 array of annealing values.
 Annealing values for time steps in between entries are computed by linearly interpolating
 between those for the previous and next entries.
 The list must be in ascneding order by time step.
 </param>
 <param name="gp">Optional grow parameters for the resulting circuit.
 The default is GrowGates with maxWires of 11.
 See <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> for more details.</param>
 <returns>The number of decoherence events which occured during the step.
 Note that this will be zero unless a decoherence model has been set on this instance.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Ramsey33">
 <summary>
 Test adiabatic evolution with a Ramsey Number problem
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Prep">
 <summary>
 Prepares the qubit state for a run.
 All qubits are resets and initialized to the ground state.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Peek(Microsoft.FSharp.Core.FSharpOption{System.Double[]})">
 <summary>
 Peeks at the current Hamiltonian matrix.
 This is based on the most recently grown circuit.
 </summary>
 <param name="anneal">An optional array of annealing values to use.
 The default is to use the most recent annealing values.</param>
 <returns>A sparse matrix representation of the Hamiltonian</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Ferro(System.Int32,System.Int32,System.Double,System.Double,System.Double,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double,System.Double}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}}})">
 <summary>
 Test adiabatic evolution with a ferro-magnetic chain
 </summary>
 <param name="repeat">How many tests to run</param>
 <param name="sCnt">How many qubits</param>
 <param name="h0">-1,0,1 = left  most down, random, up</param>
 <param name="hn">-1,0,1 = right most down, random, up</param>
 <param name="J">coupling: 1=ferro -1=anti 0=none</param>
 <param name="gammalambda">List of (time,gamma,lambda) tuples that define the annealing schedule (optional=[(30,0.0,1.0)])</param>
 <param name="runonce">true=run the simulation once and perform repeated 'virtual measurements'; false=run the simulation and measure each time (optional=false)</param>
 <param name="decohereModel">Decoherence probability per qubit per timestep [(gate,prob) list] optional=None</param>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.EnergyExpectation(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit}})">
 <summary>
 Finds the expectation value of the Hamiltonian.
 That is, given a state vector |<i>psi</i>&gt;, 
 this method computes &lt;<i>psi</i>|<b>H</b>|<i>psi</i>&gt;.
 </summary>
 <param name="stdev">Whether or not to evaluate the standard deviation as well.</param>
 <param name="anneal">An optional array of annealing values to use.
 The default is to use the most recent annealing values.</param>
 <param name="qubits">An optional state vector to take the expectation value against.
 The default is to use this.Ket.Qubits; that is, the qubits from the current Ket vector.</param>
 <returns>A tuple of the expectation value and standard deviation.
 The standard deviation will be 0.0 if it was not computed.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.Copy">
 <summary>
 Returns an instance of Spin with the same Hamiltonian parameters as this instance. 
 Simulation parameters such as run time and Trotter number are <b>not</b> copied.
 </summary>
 <returns>Copy of this instance</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.#ctor(System.Collections.Generic.Dictionary{System.Int32,System.Double},System.Collections.Generic.Dictionary{System.Tuple{System.Int32,System.Int32},System.Double})">
 <summary>
 Creates a spin Hamiltonian for simple systems that only have single spin biases and two-spin couplings. 
 The count of spins is inferred.
 </summary>
 <param name="hs">A Dictionary that maps a qubit id to that qubit's bias strength (Z term coefficient).</param>
 <param name="Js">A Dictionary that maps a pair of qubit id's to the pair's coupling strength (ZZ coefficient).</param>
</member>
<member name="M:Microsoft.Research.Liquid.Spin.#ctor(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.SpinTerm},System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.RunMode})">
 <summary>
 Creates a spin Hamiltonian from a set of spin terms.
 </summary>
 <param name="_spinTerms">The list of SpinTerms that together make up the spin Hamiltonian.</param>
 <param name="_numSpins">The number of spins in the system.</param>
 <param name="_runMode">The Trotterization type to use.
 This must be one of Trotter1, Trotter1X, or Trotter2.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Spin">
 <summary>
 Hamiltonian for spin systems, such as the Ising model or a spin glass.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.SpinTerm.Schedule">
 <summary>The numerical id (zero-based) of the annealing schedule corresponding to this term.</summary>
</member>
<member name="P:Microsoft.Research.Liquid.SpinTerm.Amplitude">
 <summary>The numerical coefficient ('strength') leading this term.</summary>
</member>
<member name="M:Microsoft.Research.Liquid.SpinTerm.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{System.Int32},System.Double)">
 <summary>
 Initializes a new SpinTerm instance.
 </summary>
 <param name="s">The numerical id, zero-based, of the annealing schedule corresponding to this term.</param>
 <param name="o">A function which performs the operation of this term over a given angle.</param>
 <param name="idx">A list of integer indices specifying the qubits to apply this term to.</param>
 <param name="a">The numerical coefficient ('strength') leading this term.</param>
</member>
<member name="M:Microsoft.Research.Liquid.SpinTerm.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},System.Double)">
 <summary>
 Initializes a new SpinTerm instance.
 </summary>
 <param name="s">The numerical id, zero-based, of the annealing schedule corresponding to this term.</param>
 <param name="o">A function which performs the operation of this term over a given angle.</param>
 <param name="a">The numerical coefficient ('strength') leading this term.</param>
</member>
<member name="T:Microsoft.Research.Liquid.SpinTerm">
 <summary>
 A single term in a Spin Hamiltonian.
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.RunMode">
 <summary>
 Trotterization types.
 </summary>
 <remarks>
 Possible values are:
 <ul>
 <li><b>Trotter1</b>:   First order Trotter</li>
 <li><b>Trotter1X</b>:  First order Trotter splitting X to each side</li>
 <li><b>Trotter1R</b>:  Reverse mode (implies reversing list and negating angles)</li>
 <li><b>Trotter1XR</b>: Reverse mode with X splitting (implies reversing list and negating angles)</li>
 <li><b>Trotter2</b>:   Second order Trotter (includes X splitting)</li>
 <li><b>Trotter2R</b>:  Second order reversed (includes X splitting)</li>
 </ul>
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.trotterN(System.Int32)">
 <summary>
 The trotter number for phase estimation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.SOs(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.SpinOrb})">
 <summary>
 Access built spin orbtial information
 </summary>
 <returns>SpinOrb list</returns>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.trotterN">
 <summary>
 The trotter number for phase estimation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.tTotal">
 <summary>
 The total evolution time for phase estimation. This is equal to 2*p1/omega.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.order">
 <summary>
 The trotter order for phase estimation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.omega">
 <summary>
 The energy range, eMax - eMin, for phase estimation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.eMin">
 <summary>
 The minimum energy for phase estimation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.eMax">
 <summary>
 The maximum energy for phase estimation.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.currentCirc">
 <summary>
 The last circuit that was run (ungrown).
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.bits">
 <summary>
 The mumber of phase estimation bits. 
 This is the bit precision plus two.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.Ua">
<summary>
 The gate function that implements a full Hamiltonian time step
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.SOs">
 <summary>
 Access built spin orbtial information
 </summary>
 <returns>SpinOrb list</returns>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.Phase">
 <summary>
 The result of phase estimation, as an angle between 0 and 2*pi.
 This value is only available after 
 <see cref="M:Microsoft.Research.Liquid.Fermion.Run(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32})">Run</see> has been called.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.Measured">
<summary>
 Get the last set of measured bits
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.MBit(System.Int32)">
<summary>
 Get measured Bit[n] as voted on by measurements (Zero or One)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.Energy">
 <summary>
 The result of phase estimation, interpreted as an energy.
 This will always be between eMin and eMax.
 This value is only available after 
 <see cref="M:Microsoft.Research.Liquid.Fermion.Run(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32})">Run</see> has been called.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Fermion.Circs">
 <summary>
 The built circuits, in bit order.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.TermExp(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.SpinOrb})">
 <summary>
 Get the expecation for each term type
 </summary>
 <returns>[tag,prob;...]</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.StateExp(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Collections.FSharpList{System.Int32})">
 <summary>
 Get expectation (mag^2) or prep and largest state entry
 </summary>
 <param name="ket">State vector to probe</param>
 <param name="preps">int list of prep state entries</param>
 <returns>prepAdr,prepMag,bigAdr,bigMag</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},Microsoft.Research.Liquid.Ket)">
 <summary>
 Runs a Fermion test from a pre-built circuit and state vector.
 See the Users Manual for details on the parameters.
 </summary>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="Ua">A gate, usually a wrapped Circuit, that implements the Hamiltonian.
 The gate's parameter is the time step to evolve by.</param>
 <param name="ket">The state vector to use as the initial state.</param>
 <returns>A tuple of the phase estimation error bit, which will be -1 if no error occured,
 and the Fermion instance that was run.
 The <see cref="P:Microsoft.Research.Liquid.Fermion.Phase">Phase</see> and 
 <see cref="P:Microsoft.Research.Liquid.Fermion.Energy">Energy</see> properties 
 of the Fermion instance may be read to get the phase estimation results.</returns>
 <remarks>
 The possible options to specify in the dictionary are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
 <summary>
 Runs a Fermion test from a .dat file, based on a script
 A basic axecution trace is sent to both the console and the log.
 Detailed information is sent just sent to the log.
 See the Users Manual for details on the parameters.
 </summary>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="dataFile">A relative or full path to the .dat file to load.</param>
 <remarks>
 The possible options to specify in the dictionary are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">
 <summary>
 Runs a pre-loaded Fermion test based on a script.
 A basic axecution trace is sent to both the console and the log.
 Detailed information is sent just sent to the log.
 See the Users Manual for details on the parameters.
 </summary>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="data">An array of formatted strings containing orbital information.
 Each string corresponds to a single line in a .dat file.
 The string format is described in the Users Manual.</param>
 <remarks>
 The possible options to specify in the dictionary are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Runs the simulation to obtain a phase estimate. 
 A previous call to Build() or BuildSingle() is required.
 </summary>
 <param name="single">Whether or not this Hamiltonian is built into a single Unitary.</param>
 <param name="maxTries">An optional maximum number of measurements to take.
 The default is 40.</param>
 <returns>None if it succeeded, or Some (int bit position) if it failed.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Prep(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
 <summary>
 Prepares an initial state from the provided spin orbital indices.
 </summary>
 <param name="prep">The list of spin orbitals to mark as occupied.</param>
 <returns>The "prep state" with exactly the listed orbitals occupied.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.PhaseSetup(System.Int32,System.Double,System.String)">
 <summary>
 Sets up phase estimation for all runs.
 </summary>
 <param name="bits">The number of bits of phase estimation accuracy desired.</param>
 <param name="alterNoise">Magnitude of random (additive) noise to apply to evolution angles.
 Set this to 0.0 for no noise.</param>
 <param name="peType">The type of phase estimation to perform.
 Possible values are:
 <ul>
 <li><b>"circ"</b>: Basic PE on the full circuit</li>
 <li><b>"expon"</b>: Create matrix exponentiations</li>
 <li><b>"noise"</b>: Compute noise while running (uses a single Unitary)</li>
 <li><b>"file"</b>: Serialize matrix exponentation to disk</li>
 <li><b>"atan"</b>: Use arc tangent to go forward and do classical post processing</li>
 <li><b>"default"</b>: Use type that naturally goes with specified GrowPars</li>
 </ul>
 </param>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.LoadOrbs(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">
 <summary>
 Loads orbital information from an array of strings.
 </summary>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="data">An array of formatted strings containing orbital information.
 Each string corresponds to a single line in a .dat file.
 The string format is described in the Users Manual.</param>
 <returns>
 A tuple containing the single-orbital terms; the two-orbital terms;
 an informational string; and the nuclear energy.
 The orbital terms are in the proper format to pass to the Fermion constructor.
 </returns>
 <remarks>
 The possible options to specify in the dictionary are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Load(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
 <summary>
 Loads a Fermion test from a .dat file based on a script.
 </summary>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="dataFile">A relative or full path to the .dat file to load.</param>
 <returns>A single, multi-line string containing orbital information for the test number
 specified in the option dictionary.
 This string is suitable for passing (as the only element of an array) to 
 <see cref="M:Microsoft.Research.Liquid.Fermion.LoadOrbs(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">LoadOrbs</see>.</returns>
 <remarks>
 The possible options to specify in the dictionary are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Dumps out information on this simulator.
 </summary>
 <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.CompileOrbs(System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Double}})">
 <summary>
 Build Hamiltonian information (used by Fermion.BuildHam)
 </summary>
 <param name="dic">Macro dictionary</param>
 <param name="ij">One body orbital integrals</param>
 <param name="ijkl">Two body orbital integrals</param>
 <returns>Hamilton,GrowPars,Preps</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Clean">
 <summary>
 Cleans out temporary files.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.BuildHam(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">
 <summary>
 Build Hamiltonian information (used by Fermion.Run)
 </summary>
 <param name="dic">Macro dictionary</param>
 <param name="data">Test string array with all parameters</param>
 <returns>Hamilton,GrowPars,Preps,Info,eNuc</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.Build(Microsoft.Research.Liquid.GrowPars)">
 <summary>
 Builds either a grown circuit or an exponentiated unitary.
 </summary>
 <param name="gp">Grow parameters for 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>.
 If the <see cref="P:Microsoft.Research.Liquid.GrowPars.Single">Single</see>
 flag is set to true, then a single exponentiated unitary is built.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.#ctor(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}})">
 <summary>
 Creates a new Fermion instance from a prebuilt Circuit.
 </summary>
 <param name="eMin">The minimum energy to use for phase estimation.</param>
 <param name="eMax">The maximum energy to use for phase estimation.</param>
 <param name="trotterN">The Trotter number to use</param>
 <param name="bits">The number of bits of phase estimation accuracy desired.</param>
 <param name="order">The Trotter order, either 1 or 2 (first or second order).</param>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="Ua">A gate, usually a wrapped Circuit, that implements the Hamiltonian.
 The gate's parameter is the time step to evolve by.</param>
 <remarks>
 The possible options to specify are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Fermion.#ctor(System.Double,System.Double,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Double}},System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}})">
 <summary>
 Creates a new Fermion instance from orbit overlap integrals.
 </summary>
 <param name="eMin">The minimum energy to use for phase estimation.</param>
 <param name="eMax">The maximum energy to use for phase estimation.</param>
 <param name="trotterN">The Trotter number to use</param>
 <param name="bits">The number of bits of phase estimation accuracy desired.</param>
 <param name="order">The Trotter order, either 1 or 2 (first or second order).</param>
 <param name="ij">A list of tuples for single-body orbital constants.
 Each tuple represents an Hpq term, and contains p, q, and the value of Hpq.
 Note that pp terms are included in this category.</param>
 <param name="ijkl">A list of tuples for two-body orbital constants.
 Each tuple represents an Hpqrs term, and contains p, q, r, s, and the value of Hpqrs.
 Note that pqqp and pqqr terms are included in this category.</param>
 <param name="dic">A dictionary of options. See the Remarks for details.</param>
 <param name="preps">An optional specification of a 1-based electron prep list, for diagonal fix-up.
 The default is no prep and no fix-up.</param>
 <remarks>
 The possible options to specify are:
 ...
 For more information, see the Users Manual.
 </remarks>
</member>
<member name="T:Microsoft.Research.Liquid.Fermion">
 <summary>
 Hamiltonian simulation for fermionic systems.
 </summary>
 <remarks>
 This class simulates second-quantized models of electrons with a state space
 consisting of spin-up/spin-down pairs, with both one-body and two-body interactions.
 <para>
 In particular, this includes second-quantized quantum chemistry, where the state pairs
 are molecular orbitals, and the individual states are spin orbitals.
 In this case, the interaction terms come from various orbital overlap integrals.
 See the Users Manual for more detailed information.
 </para>
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.Stabilizer.Tableau">
 <summary>
 Gets the internal data in the tableau:
 <ul>
 <li>n: Number of qubits represented</li>
 <li>ints: number of ints used to represent the bits = (n >>> 5) + 1</li>
 <li>rs[2*n+1]: 0=+1 1=+i 2=-1 3=-i</li>
 <li>xs[2*n+1,ints]: X stablizer values</li>
 <li>zs[2*n+1,ints]: Z stablizer values</li>
 </ul>
 </summary>
 <returns>A tuple containing n, rs, xs, and zs.</returns>
</member>
<member name="P:Microsoft.Research.Liquid.Stabilizer.Item(System.Int32)">
 <summary>
 The current measured value for a qubit.
 </summary>
 <remarks>
 This property has a tuple value.
 The first item is a flag indicating whether the last measurement was random or forced,
 and the second item is the result of the last measurement as a 
 <see cref="T:Microsoft.Research.Liquid.Bit">Bit</see>.
 <para>
 As with any qubit, the Bit will be Unknown if the qubit has interacted since it
 was last measured.
 </para>
 </remarks>
 <param name="i">The index of the qubit in the simulator's state vector.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Stabilizer.ShowState(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Int32)">
 <summary>
 Dumps the stabilizer tableau.
 </summary>
 <param name="f">The output function to use. 
 A common output function is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="level">The indentation level. </param>
</member>
<member name="M:Microsoft.Research.Liquid.Stabilizer.Run(Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Circuit},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 Runs the circuit.
 </summary>
 <param name="circuit">An optional different circuit to run.
 This allows the tableau to be reused for different circuits.
 The default is to used the circuit the tableau was created with.</param>
 <param name="dumpAll">An option indicating that the tableau state should be
 written to the log after each gate application.
 The default is false, indicating not to log.</param>
 <param name="gaussian">An option indicating that the tableau state should
 be simplified using Gaussian elimination before being logged.
 This is ignored if <paramref name="dumpall"/> is false.
 The default is false, indicating not to perform Gaussian elimination.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Stabilizer.Gaussian">
 <summary>
 Performs a Gaussian elimination to put the tableau in quasi upper triangluar form.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Stabilizer.#ctor(Microsoft.Research.Liquid.Circuit,Microsoft.Research.Liquid.Ket)">
 <summary>
 Creates a tableau to run a circuit in the stabilizer simulator.
 </summary>
 <param name="circ">The crcuit that will be run in stabilizer mode.</param>
 <param name="ket">The state vector that will be used for execution.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Stabilizer">
 <summary>
 A stabilizer-based simulator based on CHP by Scott Aaronson and Daniel Gottesman.
 See <see href="http://arxiv.org/abs/quant-ph/0406196">arXiv:quant-ph/0406196</see>
 for more details.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Steane7.NumFixed(System.Int32)">
 <summary>
 The number of syndrome fixups performed.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Steane7.NumFixed">
 <summary>
 The number of syndrome fixups performed.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Steane7.Test1">
 <summary>
 Tests the Steane7 QECC on a single logical qubit with forced X, Y, and Z error injections.
 </summary>
 <remarks>
 The test verifies that the Steane 7 code properly decodes a prepared logical qubit
 in the face of all possible single-qubit dephasing errors on each of the 7 physical
 qubits.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Steane7.Syndrome(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 A gate function that measures the physical qubits for a single logical qubit
 and applies any necessary corrections.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
 <param name="qs">The ancilla qubits followed by physical qubits for the logical qubit.
 The number of ancillae was passed to the QECC constructor.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Steane7.Prep(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 A gate function that prepares a logical |0> qubit.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
 <param name="qs">The physical qubits for the logical qubit.
 This contains both data and syndrome qubits, but no ancillae.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Steane7.Decode(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Decodes a set of measured physical qubits to get the measured value for a logical qubit.
 </summary>
 <param name="qs">The physical qubits to decode.
 They must already have been measured.</param>
 <returns>A tuple containing the logical measured value of the logical qubit, either Zero or One,
 and the Hamming distance from the physical state to the code space.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Steane7.#ctor(Microsoft.Research.Liquid.Circuit)">
 <summary>
 Constructs a Steane code implementation for a circuit.
 </summary>
 <param name="tgt">The target Circuit to build an error-correcting circuit for.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Steane7">
 <summary>
 Implementation of a Steane 7-bit quantum error correcting code, [[7,1,3]], 
 based on the <see cref="T:Microsoft.Research.Liquid.QECC">QECC</see> class.
 <seealso cref="T:Microsoft.Research.Liquid.QECC"/>
 </summary>
 <remarks>
 This code uses 7 physical qubits per logical qubit.
 It also requires 6 ancillae.
 </remarks>
</member>
<member name="P:Microsoft.Research.Liquid.QECC.Ket">
 <summary>
 The state vector for the compiled code.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.QECC.Circuit">
 <summary>
 The error-correcting circuit built by
 <see cref="M:Microsoft.Research.Liquid.QECC.Compile">Compile</see>.
 The circuit will be built now if it hasn't already been.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Syndrome(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 A gate function that measures the physical qubits for a single logical qubit
 and applies any necessary corrections.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
 <param name="qs">The ancilla qubits followed by physical qubits for the logical qubit.
 The number of ancillae was passed to the QECC constructor.</param>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Replace(Microsoft.Research.Liquid.Gate)">
 <summary>
 Gets a replacement physical gate for an input logical gate.
 The replacement may wrap a full Circuit.
 </summary>
 <param name="g">The logical gate function to replace.</param>
 <returns>An option holding a physical gate that implements the logical gate.
 If there is no physical implementation of the logical gate, then 
 None is returned.</returns>
 <remarks>
 The default implementation replaces the Pauli gates, phase gate, Hadamard gate,
 identity gate, CNOT, and measurement with transverse versions of these gates.
 Classically-controlled versions of these gates are replaced by transverse
 versions, controlled by the decoded (logical) value of the classical control.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Prep(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 A gate function that prepares a logical |0> qubit.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
 <param name="qs">The physical qubits for the logical qubit.
 This contains both data and syndrome qubits, but no ancillae.</param>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Log2Phys(System.Int32)">
 <summary>
 Gets the physical qubits that make up a logical qubit.
 </summary>
 <param name="w">The wire ID of the logical qubit in the original non-error correcting circuit.</param>
 <returns>A list of the physical qubits that implement the logical qubit.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Inject(System.Double)">
 <summary>
 Injects dephasing errors with the given probability into the error-correcting circuit.
 </summary>
 <param name="prob">The probability of an error on execution of a gate.
 Each qubit input to the gate has this same chance of a dephasing error.
 If an error is injected, it will be either an X, Y, or Z error, with equal probability.
 Note that errors are never injected on ancilla qubits.</param>
 <returns>A tuple containing the new Circuit with errors injected as the first item
 and a list of injected error counts as the second.
 The error count list contains the count of X, Y, and Z errors injected, in that order.</returns>
 <remarks>
 Note that the errors are inserted as explicit gates into a new Circuit, rather than
 randomly being injected on each run.
 That is, if the resulting circuit is executed multiple times, the same errors will be 
 injected each time.
 To get a different set of random errors, this routine must be re-run and a new Circuit generated.
 <para>
 Also note that errors are only inserted before wrapped and extended gates (Gate types Wrap and Ext).
 In particular, this means that errors appear before logical gates rather than before physical gates.
 If the original non-error correcting circuit included wrapped or extended gates, then errors may
 be injected before those gates as well.
 </para>
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.GetMeasured(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Gets the measured values of the physical qubits that make up a logical qubit
 and returns them combined into a single integer, one bit per qubit.
 </summary>
 <param name="qs">The set of qubits to read.
 This should be the set of physical (data and syndrome) qubits for one logical qubit.</param>
 <returns>The total measured value of the qubits.
 The value of the first qubit in the list goes into the left-most (most significant) bit in the result.
 </returns>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Decode(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Decodes a set of measured physical qubits to get the measured value for a logical qubit.
 </summary>
 <param name="qs">The physical qubits to decode.
 They must already have been measured.</param>
 <returns>A tuple containing the logical measured value of the logical qubit, either Zero or One,
 and the Hamming distance from the physical state to the code space.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.Compile">
 <summary>
 Compiles the target circuit into an error-correcting version.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.QECC.#ctor(System.Int32,System.Int32,Microsoft.Research.Liquid.Circuit)">
 <summary>
 Initializes a Quantum Error Correcting Circuit (QECC).
 This base constructor must be called by all derived constructors.
 </summary>
 <param name="aCnt">The number of ancilla qubits.
 By convention ancillae come first in the state vector, before data and syndrome qubits.
 Ancilla qubits are shared across all logical qubits and are for use during decoding,
 measurement, and other operations; they are not syndrome qubits.</param>
 <param name="cCnt">The code size; that is, the number of physical qubits 
 (data and syndrome) per logical qubit.</param>
 <param name="tgt">The target Circuit to build an error-correcting circuit for.</param>
</member>
<member name="T:Microsoft.Research.Liquid.QECC">
 <summary>
 Base class for quantum error correcting codes.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Parser.Port(System.Int32)">
<summary>
 Set port to use for service access
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Parser.Port">
<summary>
 Get port to use for service access
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Parser.CommandRun(Microsoft.Research.Liquid.LiquidArgs)">
 <summary>
 Run a parse set of Liquid arguments
 </summary>
 <param name="las">LiquidArgs record</param>
 <returns>0=success 1=failure</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Parser.CommandArgs">
 <summary>
 Parse command arguments
 </summary>
 <returns>A parsed LiquidArgs record</returns>
</member>
<member name="T:Microsoft.Research.Liquid.Parser">
<summary>
 Parser for simple input language
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.ILiquidService">
 <summary>
 Interface to the LiquidService
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.IncrDllT.Run(System.String)">
 <summary>
 Run a function in the image
 </summary>
 <param name="funCall">LQD function to run with params</param>
</member>
<member name="M:Microsoft.Research.Liquid.IncrDllT.Load(System.String)">
 <summary>
 Load an assembly and update all the functions with LQD attributes
 </summary>
 <param name="outDLL">DLL that was created from a /s command</param>
</member>
<member name="M:Microsoft.Research.Liquid.IncrDllT.Compile(System.String)">
 <summary>
 Compile a script into a loadable DLL
 </summary>
 <param name="script">.fsx file to compile</param>
</member>
<member name="T:Microsoft.Research.Liquid.IncrDllT">
 <summary>
 Incremental dll handling
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.LQDents">
 <summary>
 Make a table of all LQD script callable entries
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.LQDent">
 <summary>
 LQD dictionary entries for functions and circuits
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Util.ParseArgs.FinalArg">
 <summary>
 Get final argument (after all switches)
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.PrintArgs">
 <summary>
 Print out arguments
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.LineToArgs(System.String)">
 <summary>
 Convert a command line to a list of arguments
 </summary>
 <param name="cmdLine">Command line to convert (handles double quotes)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.GetStr(System.String)">
 <summary>
 Get a string argument
 </summary>
 <param name="sw">Switch</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.GetInt(System.String)">
 <summary>
 Get an integer argument
 </summary>
 <param name="sw">Switch</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.GetFlg(System.String)">
 <summary>
 Get an flag argument
 </summary>
 <param name="sw">Switch</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.GetDbl(System.String)">
 <summary>
 Get a double argument
 </summary>
 <param name="sw">Switch</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.GetArgs``1(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Util.ArgT,``0}},Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Get a arguments as specified by the user (no defaults)
 </summary>
 <param name="make">string -> Arg -> desired type</param>
 <param name="sws">name list</param>
 <returns>List of 'a values</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.GetArg(System.String)">
 <summary>
 Get an argument as specified by the user
 </summary>
 <param name="sw">Switch key</param>
 <returns>defaultArg,helpMessage,List of matching args</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.DoParse(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Parse command line argument array (without arg0)
 </summary>
 <param name="cmdArgs">Argument list to parse</param>
 <returns>final arg,parsed switches</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.ParseArgs.#ctor(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Microsoft.Research.Liquid.Util.ArgT,System.String}})">
 <summary>
 Parse input arguments using an array of flag definitions
 </summary>
 <param name="flags">Arguments to match with command line</param>
</member>
<member name="T:Microsoft.Research.Liquid.Util.ParseArgs">
 <summary>
 Definition of command line arguments with their types and default values.
 For internal use only.
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.Util.ArgT">
 <summary>
 Argument types for command line.
 For internal use only.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Util.procStatsT.peakVMMB">
<summary>
 Peak virtual memory in megabytes
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Util.procStatsT.peakWSMB">
<summary>
 Peak working set in megabytes
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Util.procStatsT.wsetMB">
<summary>
 Working set in megabytes
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Util.procStatsT.privMB">
<summary>
 Private memory in megabytes
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.Util.procStatsT">
 <summary>
 Current process memory usage statistics.
 Returned by the procStates function.
 </summary>
 <seealso cref="M:Microsoft.Research.Liquid.Util.procStats(System.Boolean)"/>
</member>
<member name="T:Microsoft.Research.Liquid.Util.DicOpts">
<summary>
 Type abbreviation for a command option dictionary, mapping strings to strings.
 This type is used to pass detailed options to the Fermion module.
</summary>
</member>
<member name="F:Microsoft.Research.Liquid.Util.tlsT.tlsId">
<summary>
 Unique ID for this thread (used for output e.g., show)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Util.tlsT.id">
 <summary>
 Assigned an ID to this thread and return it
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.Util.LQDAttribute">
 <summary>
 Allows a function to be visable from a LIQUiD script or the command line
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Util.sortInPlace``1(``0[],System.Int32)">
 <summary>
 Simple sort in place routine optimized for tiny arrays
 </summary>
 <param name="data">Data array of comparable type</param>
 <param name="len">Amount of array to sort</param>
 <returns></returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.Random.PermAry(System.Random,System.Int32)">
 <summary>
 Create a random permutation array (call .permute with results)
 This is an extension method and may be used as if it were an instance method on Random.
 </summary>
 <param name="x">The instance of System.Random (ignore)</param>
 <param name="len">Length of array to create</param>
 <returns>Randomized array</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.Random.Normal(System.Random,System.Double,System.Double)">
 <summary>
 Add a Normal distribution to the System.Random class.
 This is an extension method and may be used as if it were an instance method on Random.
 </summary>
 <param name="x">The instance of System.Random (ignore)</param>
 <param name="mean">Mean of returned value</param>
 <param name="sd">Standard deviation of returned value</param>
 <returns>Random Gaussian value</returns>
</member>
<member name="P:Microsoft.Research.Liquid.Util.sqrt2">
 <summary>
  Highly accurate square root of 2, for use building unitary matrices.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Util.findDir(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Find a directory in a list of locations
 </summary>
 <param name="dir">Directory to find</param>
 <param name="pfxs">List of prefixes ("" = travel up the current directory tree)</param>
 <returns>Path to the directory (relative)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.SafeParallelFor(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit})">
 <summary>
 Wrapper for Parallel.For that catches exceptions thrown by the loop body, logs them, and then fails the process
 </summary>
 <param name="fromInclusive">The base of the iteration range</param>
 <param name="toExclusive">The (exclusive) top of the iteration range</param>
 <param name="bodyFunction">The body function of the loop</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showProcStats(System.String)">
 <summary>
 Print process memory usage statistics to the console and log file.
 </summary>
 <param name="nam">Tag for this log entry, up to 12 characters</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.procStats(System.Boolean)">
 <summary>
 Gets current process memory usage statistics.
 </summary>
 <param name="doCollect">Do a garbage collection before reporting?</param>
 <returns>procStatsT struct</returns>
 <seealso cref="T:Microsoft.Research.Liquid.Util.procStatsT"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.getStrPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
 <summary>
 Extracts a string macro definition from a command option dictionary.
 </summary>
 <param name="dic">The dictionary to search</param>
 <param name="nam">The macro name</param>
 <param name="def">The default value to return if the name is not found in the dictionary</param>
 <returns>Macro value if found, or else default value</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.getFlgPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Boolean)">
 <summary>
 Extracts a boolean macro definition from a command option dictionary.
 </summary>
 <param name="dic">The dictionary to search</param>
 <param name="nam">The macro name</param>
 <param name="def">The default value to return if the name is not found in the dictionary</param>
 <returns>Macro value if found, or else default value</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.getFltPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Double)">
 <summary>
 Extracts a float macro definition from a command option dictionary.
 </summary>
 <param name="dic">The dictionary to search</param>
 <param name="nam">The macro name</param>
 <param name="def">The default value to return if the name is not found in the dictionary</param>
 <returns>Macro value if found, or else default value</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.getIntsPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,Microsoft.FSharp.Collections.FSharpList{System.Int32})">
 <summary>
 Extracts an integer list macro definition from a command option dictionary.
 </summary>
 <param name="dic">The dictionary to search</param>
 <param name="nam">The macro name</param>
 <param name="def">The default value to return if the name is not found in the dictionary</param>
 <returns>Macro value if found, or else default value</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.getIntPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32)">
 <summary>
 Extracts an integer macro definition from a command option dictionary.
 </summary>
 <param name="dic">The dictionary to search</param>
 <param name="nam">The macro name</param>
 <param name="def">The default value to return if the name is not found in the dictionary</param>
 <returns>Macro value if found, or else default value</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showDump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.String)">
 <summary>
 Dumps out a string with with an optional indentation.
 </summary>
 <param name="fO">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="lO">The optional indentation level. The default is 0.</param>
 <param name="str">String to output</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.getDumpArgs(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Converts possible missing arguments to legal dump arguments.
 This function is primarily for internal use.
 </summary>
 <param name="f0">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
 <param name="l0">The optional indentation level. The default is 0.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showBareLogInd(System.Int32,System.String)">
 <summary>
 Shows an indented line of output, with no prefix, to the log file.
 This routine is used by or with various Dump() routines.
 </summary>
 <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
 <param name="line">The text to show.</param>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showBareInd(System.Int32,System.String)"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showBareInd(System.Int32,System.String)">
 <summary>
 Shows an indented line of output, with no prefix, to the console and log file.
 This routine is used by or with various Dump() routines.
 </summary>
 <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
 <param name="line">The text to show.</param>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showBareLogInd(System.Int32,System.String)"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">
 <summary>
 Shows an indented line of output to the log file.
 This routine is used by or with various Dump() routines.
 </summary>
 <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
 <param name="line">The text to show.</param>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showBareInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showBareLogInd(System.Int32,System.String)"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showInd(System.Int32,System.String)">
 <summary>
 Shows an indented line of output to the console and log file.
 This routine is used by or with various Dump() routines.
 </summary>
 <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
 <param name="line">The text to show.</param>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showBareInd(System.Int32,System.String)"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showBareLogInd(System.Int32,System.String)"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showLog``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>
 Shows a line of output to the log file.
 </summary>
 <param name="fmt">printf format parameters</param>
 <typeparam name="a">Internal type of the printf string. The F# compiler will deduce this.</typeparam>
 <returns>Internal printformat</returns>
 <seealso cref="M:Microsoft.Research.Liquid.Util.show``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.logOpen"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.logClose"/>
</member>
<member name="P:Microsoft.Research.Liquid.Util.copyright">
 <summary>
 Copyright notice for Liquid.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Util.__show(System.String)">
 <summary>
 Shows a line of output.
 This is a command line-callable routine.
 </summary>
 <param name="str">String argument to show</param>
</member>
<member name="M:Microsoft.Research.Liquid.Util.show``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>
 Shows a line of output to the console and the log file.
 </summary>
 <param name="fmt">printf format parameters</param>
 <typeparam name="a">Internal type of the printf string. The F# compiler will deduce this.</typeparam>
 <returns>Internal printformat.</returns>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showLog``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.logOpen"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.logClose"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.showFull``1(Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>
 Bottom level below all show* routines
 </summary>
 <param name="doPfx">Put a prefix on the front? (None,Some "",Some "additional")</param>
 <param name="doCons">Output to console?</param>
 <param name="doLog">Output to log?</param>
 <param name="fmt">printf format parameters</param>
 <typeparam name="a">Internal type of the printf string</typeparam>
 <returns>Internal printformat</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.conClose">
 <summary>
 Closes the open console file, if any
 </summary>
 <seealso cref="M:Microsoft.Research.Liquid.Util.conOpen"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.conOpen(System.String,System.Boolean)">
 <summary>
 Open a console file for redirection
 </summary>
 <param name="str">log name (null or "" means throw console output away)</param>
 <param name="erase">If true, erases any previous log with same name</param>
 <seealso cref="M:Microsoft.Research.Liquid.Util.show``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showLog``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.conClose"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.logName">
 <summary>
 Get the current log file name
 </summary>
 <returns>Name or null</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Util.logClose">
 <summary>
 Closes the open log file, if any
 </summary>
 <seealso cref="M:Microsoft.Research.Liquid.Util.logOpen"/>
</member>
<member name="M:Microsoft.Research.Liquid.Util.logOpen(System.String,System.Boolean)">
 <summary>
 Opens a log file (used by show)
 </summary>
 <param name="str">log name (null or "" means NONE)</param>
 <param name="erase">If true, erases any previous log with same name</param>
 <seealso cref="M:Microsoft.Research.Liquid.Util.show``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.showLog``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})"/>
 <seealso cref="M:Microsoft.Research.Liquid.Util.logClose"/>
</member>
<member name="P:Microsoft.Research.Liquid.Util.outputPrefix">
<summary>
 Global override for the prefix used for output functions (show and variants).
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.Util">
<summary>
 General utilities used by the rest of the system
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Native.F77Array`1.Seq">
<summary>
 Get a sequence of all elements
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Native.F77Array`1.Length">
<summary>
 Get total length
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Native.F77Array`1.Data">
<summary>
 Get raw array (as a vector)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1._rvCols">
<summary>
 Reverse columns into a new array
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1._redim(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Create an array from an old one at offset o for n items
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1._rDim(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Redimension an array starting at relative index [r,c]  for [numR,numC]
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Show(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Debugging output
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Row(System.Int32)">
<summary>
 Extract a single row as a .net vector
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Pin``1(Microsoft.FSharp.Core.FSharpFunc{System.IntPtr,``0})">
<summary>
 Pin and return address into object
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Off(System.Int32,System.Int32)">
<summary>
 Get a vector given a relative offset and abs length
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Off(System.Int32)">
<summary>
 Get a vector given a relative offset
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Cols(System.Int32,System.Int32)">
<summary>
 Extract relative columns with abs count 
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Cols(System.Int32)">
<summary>
 Extract relative columns
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Col(System.Int32)">
<summary>
 Extract absolute column
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.Check(System.Int32)">
<summary>
 Check legality of length
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,`0[])">
<summary>
 Create for de-serialization
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.#ctor(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,`0})">
<summary>
 Create new array with initial value function
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.#ctor(`0[])">
<summary>
 Create new array with initial column
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.#ctor(System.Int32,System.Int32,`0)">
<summary>
 Create new array with initial value 
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.F77Array`1.#ctor(System.Int32,System.Int32)">
<summary>
 Create Fortran based array
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.Native.F77Array`1">
 <summary>
  Fortran style arrays for interfacing to external modules (still 0 based)
 </summary>
</member>
<member name="T:Microsoft.Research.Liquid.Native.refT`1">
 <summary>
 Pinned reference type to protect external modules from garbage collection
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Native.LoadBLAS">
<summary>
 Load the BLAS native libraries. Return any exception if we&apos;re not successful
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.zsteqr(System.String,System.Int32,Microsoft.Research.Liquid.Native.F77Array{Microsoft.Research.Liquid.Complex},Microsoft.Research.Liquid.Native.F77Array{Microsoft.Research.Liquid.Complex},Microsoft.Research.Liquid.Native.F77Array{Microsoft.Research.Liquid.Complex},System.Int32,Microsoft.Research.Liquid.Native.F77Array{Microsoft.Research.Liquid.Complex},Microsoft.Research.Liquid.Native.refT{System.Int32})">
<summary>
 Eigenvalues/vecs of a symetric tri-diagonal matrix
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.zgeev(Microsoft.Research.Liquid.Native.F77Array{Microsoft.Research.Liquid.Complex})">
<summary>
 Generalized eigenvalues/vectors, returns: (eigs[j],vecs[*,j]) [Note: a is overwritten!]
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.dsyevr``2(Microsoft.Research.Liquid.Native.F77Array{System.Double},``0,``1)">
<summary>
 Eigenvalue/vector on double array (matrix must be *COLUMN* major order!)
 il=lower eigenvalue index (&gt;=1) iu=upper eigenvalue index (&lt;=n)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.ssteqr(System.String,System.Int32,Microsoft.Research.Liquid.Native.F77Array{System.Single},Microsoft.Research.Liquid.Native.F77Array{System.Single},Microsoft.Research.Liquid.Native.F77Array{System.Single},System.Int32,Microsoft.Research.Liquid.Native.F77Array{System.Single},Microsoft.Research.Liquid.Native.refT{System.Int32})">
<summary>
 Eigenvalues/vecs of a symetric tri-diagonal matrix
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.dgeev(Microsoft.Research.Liquid.Native.F77Array{System.Double})">
<summary>
 Generalized eigenvalues/vectors, returns: (valReal[j],valImag[j],vecs[*,j])
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.sgeev(Microsoft.Research.Liquid.Native.F77Array{System.Single})">
<summary>
 Generalized eigenvalues/vectors, returns: (valReal[j],valImag[j],vecs[*,j])
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.ssyevr``2(Microsoft.Research.Liquid.Native.F77Array{System.Single},``0,``1)">
<summary>
 Eigenvalue/vector on single array (matrix must be *COLUMN* major order!)
 il=lower eigenvalue index (&gt;=1) iu=upper eigenvalue index (&lt;=n)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Native.LAPACK.SafeMinS">
<summary>
 Accuracy
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.Native.BLAS">
<summary>
 BLAS lineary algebra interfaces
</summary>
</member>
<member name="T:Microsoft.Research.Liquid.Native.NATIVE">
<summary>
 Native interop for LAPACK and BLAS
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LoadCache">
 <summary>
 Preload the cache with basic gates: Paulis, measurement, Hadamard, phase, CNOT, Toffoli, swap, and T.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.T_BC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Tuple{Microsoft.Research.Liquid.Bit,System.Int32}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a transverse classically-controlled gate.
 </summary>
 <param name="decode">The code-specific decode function that takes a list of measured qubits 
 and returns a logical value (One or Zero) and the Hamming distance from the current state 
 to a valid code state.</param>
 <param name="f">The (transverse) parent gate to control</param>
 <param name="qs">The first codeSize qubits in the list are passed to the <paramref name="decode"/> 
 function to compute a logical Zero or One state. 
 If the decoded state is One, then the remaining qubits are passed to the parent gate.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Transverse(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Expands a parent gate to a transverse version.
 </summary>
 <remarks>
 If the parent gate operates on a single qubit, then it is applied to each qubit in the code.
 If the parent gate applies to two qubits, then it is applied to pairs of qubits selected
 from the first and second half of the list.
 For example, if the code contained 3 qubits,
 so that the qubits to operate on would contain 6 qubits,
 then the gate would be applied to pairs 0 and 3, 1 and 4, and 2 and 5.
 <para>It is an error if the parent gate takes more than two qubits.</para>
 <para>The transverse gate's name is the parent's name with a "_T" suffix.</para>
 </remarks>
 <param name="cCnt">The total number of qubits in code</param>
 <param name="f">The parent gate to expand</param>
 <param name="qs">The qubits that final gate will operate on</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.CCgate(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a parent gate under two-qubit quantum control.
 The parent must be a unitary gate.
 </summary>
 <param name="f">The gate to control.</param>
 <param name="qs">The first two qubits are the control, and the remainder are passed to the parent gate.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.CgateNC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a parent gate under quantum control.
 The parent must be a unitary gate.
 The resulting gate is not cached.
 </summary>
 <param name="f">The gate to control.</param>
 <param name="qs">The first qubit is the control qubit, and the remainder are passed to the parent gate.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Cgate(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a parent gate under quantum control.
 The parent must be a unitary gate.
 </summary>
 <param name="f">The gate to control.</param>
 <param name="qs">The first qubit is the control qubit, and the remainder are passed to the parent gate.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.CCNOT(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Toffoli or Controlled-Controlled-NOT gate
 </summary>
 <param name="qs">The first two qubits in the list are the control qubits, and the third qubit is the target,</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.SWAP(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a swap gate, exchanging the quantum states of two qubits.
 </summary>
 <param name="qs">The states of the first two qubits in the list are swapped.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.U(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a quantum-controlled rotation.
 This is often used as an eigenvalue measuring device
 </summary>
 <param name="k">The rotation angle, as a fraction of 2*pi.</param>
 <param name="qs">The head qubit is the control qubit, the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.CNOT(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a quantum-controlled NOT gate
 </summary>
 <param name="qs">The head qubit is the control qubit, the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.R(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a 2pi/2^K rotation gate gate. 
 </summary>
 <param name="k">The rotation parameter</param>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.T(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a pi/8 gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.I(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli I (identify) gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.CZ(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a quantum-controlled Pauli Z gate. 
 </summary>
 <param name="qs">The head qubit is the control qubit, the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Z(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli Z gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Y(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli Y gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.X(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli X gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.S(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a phase gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.H(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Hadamard gate. 
 </summary>
 <param name="qs">The head qubit of this list is operated on.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Adj(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs the adjoint of the parent gate.
 This only works if the parent gate is a unitary gate.
 </summary>
 <param name="f">The gate to take the adjoint of</param>
 <param name="qs">A list of qubits which are passed to the adjoint.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.PC(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a gate based on a classical condition.
 The parent gate is executed if the test function returns true.
 Typically this condition is based on the results of one or more joint parity measurements.
 <seealso cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)"/>
 </summary>
 <param name="lbl">A label for drawing.</param>
 <param name="tst">The test function used to control execution of the parent gate.</param>
 <param name="f">The parent gate to control</param>
 <param name="qs">A list of qubits which will be passed to the parent gate
 if it is executed.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.BCany(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a gate under classical control.
 This gate allows an arbitrary condition to be specified.
 The parent gate will be executed if the condition function evaluates to true.
 <seealso cref="M:Microsoft.Research.Liquid.Operations.BC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})"/>
 </summary>
 <param name="cnt">The count of binary control bits. 
 These bits will not be passed to the parent gate.</param>
 <param name="tst">The condition function that controls execution of the parent gate.</param>
 <param name="f">The parent gate to control</param>
 <param name="qs">A list of qubits. 
 The initial <paramref name="cnt"/> qubits are provided to the condition function,
 and the remainder are passed to the parent gate if it is executed.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.BC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a gate under classical control.
 The parent gate will be executed if the control qubit has a measured value of One.
 <seealso creaf="M:Microsoft.Research.Liquid.Operations.BCany(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})"/>
 </summary>
 <param name="f">The parent gate to control</param>
 <param name="qs">A list of qubits. 
 The head qubit is the control qubit; its measured state determines whether or not
 the parent gate is executed.
 The tail of the list is passed to the parent gate if it is executed.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.NativeDbg(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs any desired native operations at this point in the circuit.
 This version doesn't appear in a circuit drawing.
 <seealso cref="M:Microsoft.Research.Liquid.Operations.Native(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})"/>
 </summary>
 <param name="f">The native function to call.</param>
 <param name="qs">The list of qubits to pass to the native operation.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Native(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs any desired native operations at this point in the circuit.
 <seealso cref="M:Microsoft.Research.Liquid.Operations.NativeDbg(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})"/>
 </summary>
 <param name="f">The native function to call.</param>
 <param name="qs">The list of qubits to pass to the native operation.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Restore(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Resets a qubit after it has been measured.
 This allows quantum gates to be performed against the collapsed qubit.
 The initial state of the qubit will be its last measured state.
 See the <see cref="">M</see> gate.
 </summary>
 <param name="qs">A list of qubits; the head of the list is reset.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Reset(Microsoft.Research.Liquid.Bit,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Resets a qubit to a specified initial state after it has been measured.
 This allows quantum gates to be performed against the collapsed qubit.
 See the <see cref="">M</see> gate.
 </summary>
 <param name="b">The initial state of the reset qubit, either Zero or One.</param>
 <param name="qs">A list of qubits; the head of the list is reset.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.DP(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Depolarizing channel using four Kraus operators (always put the most probable one first)
 </summary>
 <param name="prob">Probability of depolarizing in X,Y or Z</param>
 <param name="qs">The list of qubits that the Kraus operators touch</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.AD(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Amplitude Damping Channel using two Kraus operators (always put the most probable one first)
 </summary>
 <param name="prob">Probability of damping</param>
 <param name="qs">The list of qubits that the Kraus operators touch</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.JM(System.String,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a joint parity measurement in the given basis on a list of qubits.
 The result of the measurement is stored in the Ket's symbol table.
 The state vector is collapsed according to the result of the measurement.
 </summary>
 <param name="tag">If not empty, the symbol name to store the measurement result under.
 See <see cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">Ket.Symbol</see>.</param>
 <param name="basis">The basis to measure in.
 This may be a string of any length, including empty, made up of X, Y, and Z characters.
 Each character is used to specify the basis for the corresponding qubit being measured.
 If there are more qubits than bases specified, then the last basis character is repeated.
 If this is an empty string, then it is treated as "Z", which performs a joint measurement
 of all qubits in the computational basis.</param>
 <param name="qs">The list of qubits to jointly measure.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.JMx(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a joint parity measurement in the X basis on a list of qubits.
 The result of the measurement is stored in the Ket's symbol table.
 The state vector is collapsed according to the result of the measurement.
 </summary>
 <param name="tag">If not empty, the symbol name to store the measurement result under.
 See <see cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">Ket.Symbol</see>.</param>
 <param name="qs">The list of qubits to jointly measure.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.JMz(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a joint parity measurement in the computational basis on a list of qubits.
 The result of the measurement is stored in the Ket's symbol table.
 The state vector is collapsed according to the result of the measurement.
 </summary>
 <param name="tag">If not empty, the symbol name to store the measurement result under.
 See <see cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">Ket.Symbol</see>.</param>
 <param name="qs">The list of qubits to jointly measure.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.M(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a measurement of a single qubit in the computational basis.
 The result of the measurement is stored in the measured qubit; 
 see <see cref="P:Microsoft.Research.Liquid.Qubit.Bit(Microsoft.Research.Liquid.Bit)">Qubit.Bit</see>.
 The state vector is collapsed according to the result of the measurement.
 The measured qubit becomes "classical" and must be reset before any further
 quantum gates are performed on it.
 </summary>
 <param name="qs">A list of qubits; the head of the list is measured.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelRaw(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a raw label to a circuit drawing.
 The provided string should contain the
 <see href="http://physics.unm.edu/CQuIC//Qcircuit/">Q-Circuit</see>
 commands used to draw the label.
 Note that labels drawn using this gate will only appear when rendered to "qc" format.
 </summary>
 <param name="cmd">The string to use to draw the label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelCD(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a framed label to a circuit drawing.
 The label be centered in and will fill the current cell.
 The label will have a box drawn tightly around it.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelC(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a label to a circuit drawing.
 The label be centered in and will fill the current cell.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelR(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a label to a circuit drawing.
 The label will appear centered on the line representing the qubit,
 on the right side of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelL(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a label to a circuit drawing.
 The label will appear centered on the line representing the qubit,
 on the left side of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelD(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a label to a circuit drawing.
 The label will appear below the line representing the qubit,
 in the center of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.LabelU(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a label to a circuit drawing.
 The label will appear above the line representing the qubit,
 in the center of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.Label(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Adds a label to a circuit drawing.
 The label will appear above the line representing the qubit,
 in the center of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
 <param name="nam">The string to use as a label.</param>
 <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.op_BangLess(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 In F# code, this operator is named !&lt;.
 Gets the gate definition from a gate function.
 This is usually used to discover the "parent" gate.
 </summary>
 <param name="f">The gate function we want the Gate for.</param>
 <param name="qs">A list of Qubits that can be used to find the gate.</param>
 <returns>The Gate corresponding to the gate function.
 Note that if f is not a gate function, this function will raise an exception.</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.op_BangBang(System.Object)">
 <summary>
 In F# code, this operator is named !!.
 Builds a list of Qubits from a wide variety of possible inputs.
 </summary>
 <remarks>
 The inputs that are interprested by this operator are:
 <ul>
 <li><b>A Ket</b>, which is interpreted as the complete list of Qubits in the Ket.</li>
 <li><b>A single Qubit</b>, which is interpreted as a single-element list.</li>
 <li><b>A two-tuple of Qubits</b>, which is interpreted as a two-element list.</li>
 <li><b>A three-tuple of Qubits</b>, which is interpreted as a three-element list.</li>
 <li><b>A list of Qubits</b>, which is returned directly.</li>
 <li><b>A two-tuple of lists of Qubits</b>, which are concatenated into a single list.</li>
 <li><b>A three-tuple of lists of Qubits</b>, which are concatenated into a single list.</li>
 <li><b>A list of lists of Qubits</b>, which are concatenated into a single list.</li>
 <li><b>A two-tuple of a list of Qubits and a single Qubit</b>, which are concatenated into a single list.</li>
 <li><b>A two-tuple of a single Qubit and a list of Qubits</b>, which are concatenated into a single list.</li>
 <li><b>A two-tuple of a list of Qubits and an integer</b>, which is interpreted as the single-element list
 containing the item in the list indexed by the integer.</li>
 <li><b>A three-tuple of a list of Qubits and two integers</b>, which is interpreted as the two-element list
 containing the items in the list indexed by the two integers.</li>
 <li><b>A four-tuple of a list of Qubits and three integers</b>, which is interpreted as the three-element list
 containing the item in the list indexed by the three integers.</li>
 <li><b>A two-tuple of a list of Qubits and a list of integers</b>, which is interpreted as the list
 containing the items in the Qubit list indexed by the elements in the integer list.</li>
 </ul>
 </remarks>
 <param name="qs">The value to interpret as a list of Qubits.</param>
 <returns>A list of Qubits</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.op_GreaterBangLess``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 In F# code, this operator is named &gt;!&lt;.
 Applies a function to each qubit in a list, passing a parameter to the function as well as each Qubit.
 The parameter values may be a list of a single value which is then passed to each invocation.
 </summary>
 <param name="f">The function to call.
 The extra parameter must be the first argument to the function.</param>
 <param name="args">Either a list of arguments, one per Qubit, or a single value
 that is passed with each Qubit.</param>
 <param name="qs">The list of qubits to iterate over.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Operations.op_GreaterLess(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 In F# code, this operator is named &gt;&lt;.
 Applies a function to each qubit in a list of Qubits.
 </summary>
 <param name="f">The gate function to call.</param>
 <param name="qs">The list of qubits to iterate over.</param>
</member>
<member name="T:Microsoft.Research.Liquid.Operations">
 <summary>
 The Operations module provides definitions of basic gates.
 It also includes some handy operators for manipulating qubit lists,
 and some operations for building gates from existing gates.
 </summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.msg">
<summary>
 Message if failure (else 0 length string)
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.elapsed">
<summary>
 elapsed time in seconds
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.coPrime">
<summary>
 Coprime used
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.qCnt">
<summary>
 Qubit count
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.n">
<summary>
 Number of bits needed
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.f2">
<summary>
 Factor2 0 = Failed
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.f1">
<summary>
 Factor1 0 = Failed
</summary>
</member>
<member name="P:Microsoft.Research.Liquid.Shor.ShorResult.N">
<summary>
 Number to factor
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.ShorResult.Fail(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Report a failure
 </summary>
 <param name="msg">Message to report back</param>
</member>
<member name="T:Microsoft.Research.Liquid.Shor.ShorResult">
 <summary>
 Results returned from Shor
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.Shor(System.Int32,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>
 Top level call to Shor factoring algorithm
 </summary>
 <param name="N">Number to factor (0=run tests and dump diagrams on components)</param>
 <param name="doCirc">Compile to circuit (and optimize) or run native gates</param>
 <param name="chkAbort">Routine to throw exception if abort desired (for long runs)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.ShorRun(System.Boolean,System.Int32[],System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Run all steps of Shor's algorithm
 </summary>
 <param name="doCirc">Doing Circuits or direct execution</param>
 <param name="rslt">Bit results from each step</param>
 <param name="N">Number to factor</param>
 <param name="a">Classical value on left</param>
 <param name="qs">Qubits to operate on</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.testShorGates(System.Boolean)">
 <summary>
 Test sub-circuits
 </summary>
 <param name="doCirc">Compile circuits first, or just call gates directly?</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.setBits(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Re-Animate qubits based on classical value in a. 
 Measure qubit if it isn't already measured
 </summary>
 <param name="a">Value to re-animate qubits from</param>
 <param name="qsIn">Measured qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.lblQs(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Attach a label (for drawing) on each qubit
 </summary>
 <param name="str">String to use as label</param>
 <param name="qs">Qubits to label</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.getGroups(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Break apart qubits into logical groups
 </summary>
 <param name="qs">Input qubits</param>
 <returns>n=group size,m=control qubit,xs=n x-values,bs=n+1 b-values,ancilla</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.genQubits(System.Int32)">
 <summary>
 Generate all the qubits needed in state vector
 </summary>
 <param name="N">Number that we're factoring</param>
 <returns>Qubits created</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.Ua(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Top level gate (does modular exponentiation)
 </summary>
 <param name="N">Number to MOD</param>
 <param name="a">Classical number to exponentiate</param>
 <param name="qs">Qubits containint QFT(b)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.MulModNAdj(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Multiply classical a with QFT(b) creating QFT(a*b) mod N
 </summary>
 <param name="N">Number to use for mod</param>
 <param name="a">Number to multiply on left</param>
 <param name="qs">Qubits containing QFT(b)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.MulModN(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Multiply classical a with QFT(b) creating QFT(a*b) mod N
 </summary>
 <param name="N">Number to use for mod</param>
 <param name="a">Number to multiply on left</param>
 <param name="qs">Qubits containing QFT(b)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.AddModNAdj(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Add classical a to QFT(b) creating QFT(a+b) mod N
 </summary>
 <param name="N">Number to use for mod</param>
 <param name="a">Number to add on left</param>
 <param name="qs">Qubits containing QFT(b)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.AddModN(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Add classical a to QFT(b) creating QFT(a+b) mod N
 </summary>
 <param name="N">Number to use for mod</param>
 <param name="a">Number to add on left</param>
 <param name="qs">Qubits containing QFT(b)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.QFTAdj(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Take Inverse QFT
 </summary>
 <param name="qs">Qubits to take inverse QFT of</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.QFT(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Take QFT
 </summary>
 <param name="qs">Qubits to take QFT of</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CCAddAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Controlled-Controlled N bit adder (a+QFT(b))
 </summary>
 <param name="a">Number to add to</param>
 <param name="qs">[0-1]=Control [2 to n+1]=QFT of b to add</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CCAdd(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled-Controlled N bit adder (a+QFT(b))
 </summary>
 <param name="a">Number to add to</param>
 <param name="qs">[0-1]=Control [2 to n+1]=QFT of b to add</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CAddAAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Controlled N bit adder (a+QFT(b))
 </summary>
 <param name="a">Number to add to</param>
 <param name="qs">[0]=Control [1-n]=QFT of b to add</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CAddA(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled N bit adder (a+QFT(b))
 </summary>
 <param name="a">Number to add to</param>
 <param name="qs">[0]=Control [1-n]=QFT of b to add</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.AddAAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse N bit adder (a+QFT(b))
 </summary>
 <param name="a">Number to add to</param>
 <param name="qs">QFT of b to add</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.AddA(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 N bit adder (a+QFT(b))
 </summary>
 <param name="a">Number to add to</param>
 <param name="qs">QFT of b to add</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.opGen(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Int32,System.Boolean)">
 <summary>
 Support for adders and QFT (generate the needed operator on a)
 </summary>
 <param name="a">Number to operate on</param>
 <param name="qs">Qubits to operate on</param>
 <param name="ctrlCnt">How many controls?</param>
 <param name="inv">Is this the inverse gate?</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CCRAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Controlled-Controlled rotation gate
 </summary>
 <param name="k">Rotation by 2^k</param>
 <param name="qs">Qubits ([0;1]=Controls [2]=rotated)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CCR(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled-Controlled rotation gate
 </summary>
 <param name="k">Rotation by 2^k</param>
 <param name="qs">Qubits ([0;1]=Controls [2]=rotated)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CRAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Controlled rotation gate
 </summary>
 <param name="k">Rotation by 2^k</param>
 <param name="qs">Qubits ([0]=Control [1]=rotated)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.CR(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled rotation gate
 </summary>
 <param name="k">Rotation by 2^k</param>
 <param name="qs">Qubits ([0]=Control [1]=rotated)</param>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.dbgRpt(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
<summary>
 Debug report of state of the carry bit from the top
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.rat(System.Double,System.UInt64)">
 <summary>
 This function finds the best rational
 numeratro,denominator for approximating p / q for c with q &lt; mxDen
 </summary>
 <param name="f">Number to search rational denominator for</param>
 <param name="mxDen">denominator must be less than this</param>
 <returns>p,q</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.denominator(System.Double,System.UInt64)">
 <summary>
 This function finds the denominator q of the best rational
 denominator for approximating p / q for c with q &lt; qmax.
 </summary>
 <param name="c">Number to search rational denominator for</param>
 <param name="qMax">denominator must be less than this</param>
 <returns>q (in p/q)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.modExp(System.Int32,System.Int32,System.Int32)">
 <summary>
 Find x^a mod n (Russian peasant method).
 </summary>
 <param name="x">Base</param>
 <param name="a">Exponent</param>
 <param name="n">Mod</param>
 <returns>x^a mod n</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.coPrime(System.Int32)">
 <summary>
 Find a legal coprime of a number
 </summary>
 <param name="N">Number to find co-prime of</param>
 <returns>Co-Prime</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.gcd(System.Int32,System.Int32)">
 <summary>
 Take GCD of a and b
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns>GCD</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.primeFactors(System.Int32)">
 <summary>
 Return the prime factors of a number (if the number is the product of two primes)
 </summary>
 <param name="n">Number to test</param>
 <returns>Prime factors (or empty list)</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.isPrimePower(System.Int32)">
 <summary>
 Check for prime power
 </summary>
 <param name="n">Number to check</param>
 <returns>If it's a prime power</returns>
</member>
<member name="M:Microsoft.Research.Liquid.Shor.isPrime(System.Int32)">
 <summary>
 Check for prime
 </summary>
 <param name="n">Number to check</param>
 <returns>If it's prime</returns>
</member>
<member name="T:Microsoft.Research.Liquid.HamiltonianGates.TermInfo">
 <summary>
 Hamiltonian term info
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.LoadCache">
 <summary>Preload the cache with the ZZ, Ybasis, and YbasisAdj gates.</summary>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqrsCNOT(System.Double,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Double Excitation operator
 </summary>
 <param name="theta">Angle</param>
 <param name="pieces">List of (piece#,mult)</param>
 <param name="pqrs">Index in qs (without ancilla)</param>
 <param name="qs">Our qubits (anc::[p...s]) or without anc if not DoPE.v</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqrsMatt2(System.Double,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Double Excitation operator
 </summary>
 <param name="theta">Angle</param>
 <param name="pieces">List of (piece#,mult)</param>
 <param name="pqrs">Index in qs (without ancilla)</param>
 <param name="qs">Our qubits (anc::[p...s;entQ]) or without anc if not DoPE.v</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqrsMatt(System.Double,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Double Excitation operator
 </summary>
 <param name="theta">Angle</param>
 <param name="pieces">List of (piece#,mult)</param>
 <param name="pqrs">Index in qs (without ancilla)</param>
 <param name="qs">Our qubits (anc::[p...s]) or without anc if not DoPE.v</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hpqrs(System.Double,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Double Excitation operator
 </summary>
 <param name="theta">Angle</param>
 <param name="pieces">List of (piece#,mult)</param>
 <param name="pqrs">Index in qs (without ancilla)</param>
 <param name="qs">Our qubits (anc::[p...s]) or without anc if not DoPE.v</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqqrCNOT(System.Double,Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>    /// NumberExcitation operator
 </summary>
 <param name="theta">Angle</param>
 <param name="pqrs">Index in qs (without ancilla)</param>
 <param name="qs">0=Anc 1..N=qubits to operator on</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hpqqr(System.Double,Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 NumberExcitation operator
 </summary>
 <param name="theta">Angle</param>
 <param name="pqrs">Index in qs (without ancilla)</param>
 <param name="qs">0=Anc 1..N=qubits to operator on</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hpqqp1(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a single quantum chemistry Hpqqp term.
 This represents a two-particl Colounb and exchange energy.
 </summary>
 <param name="theta">The angle to rotate by.</param>
 <param name="qs">The first qubit should correspond to the 'p' state
 and the second qubit to the 'q' state.</param>
 <summary>
 Coloumb and Exchange operator (individual version, one per term)
 </summary>
 <param name="theta">Angle</param>
 <param name="qs">All qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqqpCNOT(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{System.Int32},System.Double}},System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Coloumb and Exchange operator (single global version. Requires a PE qubit)
 </summary>
 <param name="info">All the spinorbital parameters needed (without ancilla index)</param>
 <param name="theta">Angle</param>
 <param name="qs">All qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hpqqp(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{System.Int32},System.Double}},System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a list of quantum chemistry Hpqqp terms.
 This represents two-partical Coloumb and exchange energy.
 The application is controlled by a phase estimation qubit
 if DoPE.v is true.
 </summary>
 <param name="info">A list of Hpqqp terms.
 Each term is a tuple of a list of qubit indices and a rotation angle.
 Each list of indices should be exactly two items long.
 The indices are each the index in qs of the qubits corresponding to
 the p and q states for that term, except that if DoPE.v is true, then
 the indices need to be decremented because the phase estimation qubit is skipped.
 </param>
 <param name="theta">The angle to rotate by.</param>
 <param name="qs">The first qubit is the phase estimation qubit.
 The remaining qubits represent the possible states.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqCNOT(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Excitation operator (New way to do this from Matt Hastings)
 </summary>
 <param name="theta">Angle</param>
 <param name="qs">0=qP 1=qQ</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqMatt2(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Excitation operator (New way to do this from Matt Hastings)
 </summary>
 <param name="theta">Angle</param>
 <param name="qs">0=PE 1=qP last-1=qQ last=entQ</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HpqMatt(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Excitation operator (New way to do this from Matt Hastings)
 </summary>
 <param name="theta">Angle</param>
 <param name="qs">0=qP 1=qQ</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hpq(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a quantum chemistry Hpq term.
 This represents a single electron excitation energy.
 </summary>
 <param name="theta">The angle to rotate by.</param>
 <param name="qs">The first qubit should correspond to the 'p' state
 and the second qubit to the 'q' state.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hp(System.Boolean,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Single site operator (does NOT preserve particle number)
 </summary>
 <param name="doY">Selects Ybasis instead of X</param>
 <param name="theta">Angle (= 2 * epsilon)</param>
 <param name="qs">[ancilla],q0 ...,qP (this is differnt than other gates)</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.HppCNOT(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Number operator
 </summary>
 <param name="theta">Angle</param>
 <param name="qs">0=qubit</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Hpp(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a quantum chemistry Hpp term.
 This represents an occupation number energy.
 </summary>
 <param name="theta">The angle to rotate by.</param>
 <param name="qs">The first qubit should correspond to the 'p' state.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.UnEntangle(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Unentangles a list of qubits.
 This is useful for building Jordan-Wigner strings.
 </summary>
 <param name="ladder">A list of pairs of qubit indices to entangle.
 Each entry should have a tuple of two indices that refer to qubits in the
 <paramref name="qs"/> list.
 The entangle gate will wrap a sequence of CNOT gates, one for each tuple,
 each with the control being the first qubit in the tuple and 
 the target being the second in the tuple.
 The CNOT gates are built in the reverse order of the ladder list.</param>
 <param name="qs">The qubits to build the ladder from.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Entangle(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Entangles a list of qubits.
 This is useful for building Jordan-Wigner strings.
 </summary>
 <param name="ladder">A list of pairs of qubit indices to entangle.
 Each entry should have a tuple of two indices that refer to qubits in the
 <paramref name="qs"/> list.
 The entangle gate will wrap a sequence of CNOT gates, one for each tuple,
 each with the control being the first qubit in the tuple and 
 the target being the second in the tuple.
 The CNOT gates are built in ladder list order.</param>
 <param name="qs">The qubits to build the ladder from.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.CGtheta(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a controlled global phase rotation.
 </summary>
 <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.CTtheta(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a controlled T rotation.
 </summary>
 <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.CRx(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Controlled Pauli X rotation.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Rx(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli X rotation.
 This is functionally equivalent to <c>Rpauli theta X qs</c>, 
 but has some additional drawing options.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.CRy(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Controlled Pauli Y rotation.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Ry(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli Y rotation.
 This is functionally equivalent to <c>Rpauli theta Y qs</c>, 
 but has some additional drawing options.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.CRz(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Controlled Pauli Z rotation.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Rz(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli Z rotation.
 This is functionally equivalent to <c>Rpauli theta Z qs</c>, 
 but has some additional drawing options.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.YbasisAdj(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a basis change from Y to Z.
 This is the adjoint of 
 <see cref="M:Microsoft.Research.Liquid.HamiltonianGates.Ybasis(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">Ybasis</see>.
 </summary>
 <param name="qs">The first qubit in the list has its basis changed.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Ybasis(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a basis change from Z to Y.
 </summary>
 <param name="qs">The first qubit in the list has its basis changed.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Gtheta(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a global phase rotation.
 This is functionally equivalent to <c>Rpauli (2.0*theta) I qs</c>, 
 but has some additional drawing options.
 </summary>
 <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Ttheta(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a phase gate rotation.
 This is functionally equivalent to <c>Rpauli (2.0*theta) T qs</c>, 
 but has some additional drawing options.
 </summary>
 <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
 <param name="factor">A multiplier, used to compute the gate label.</param>
 <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.ZZR(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli ZZ rotation; that is, a simultaneous Z rotation of two qubits.
 This is equivalent to <c>Rpauli (2.0*theta) ZZ qs</c>.
 </summary>
 <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
 <param name="qs">The first two qubits in the list are rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.ZR(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a Pauli Z rotation. This is equivalent to <c>Rpauli (2.0*theta) Z qs</c>.
 </summary>
 <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.Rpauli(System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs an arbitrary rotation based on an existing gate.
 The base gate may be any unitary gate with a Hermitian, idempotent matrix.
 Of course, all Pauli gates satisfy this criteria.
 </summary>
 <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
 <param name="f">The gate to base the rotation on.</param>
 <param name="qs">The first qubit in the list is rotated.</param>
</member>
<member name="M:Microsoft.Research.Liquid.HamiltonianGates.ZZ(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Performs a ZZ gate: Pauli Zs on consectutive wires.
 This is used for coupling strength.
 </summary>
 <param name="qs">The first two qubits will have Z performed on them.</param>
</member>
<member name="T:Microsoft.Research.Liquid.HamiltonianGates">
 <summary>A collection of gates that are useful for Hamiltonian simulation and annealing.</summary>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.Grover(Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Modified Grover's search for QuAM
 </summary>
 <param name="pats">Patterns that we've loaded</param>
 <param name="poss">Patterns that we're searching for</param>
 <param name="qs">Qubits to search</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.GStep(Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Grover step
 </summary>
 <param name="pats">Patterns that we're searching for</param>
 <param name="qs">Qubits to apply Grover step</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.GDiff(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Grover diffusion operator
 </summary>
 <param name="qs">Qubits to define Grover for</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.InFLIP(Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Identity negated with items flipped (for Grover's algorithm)
 </summary>
 <param name="flips">List of indicies to flip signs</param>
 <param name="qs">Qubits to define identity for</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.IFLIP(Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Identity with items flipped (for Grover's algorithm)
 </summary>
 <param name="flips">List of indicies to flip signs</param>
 <param name="qs">Qubits to define identity for</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.LOAD(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 LOAD gate: High level QuAM gate to load one pattern
 </summary>
 <param name="p">Total number of patterns to store</param>
 <param name="prv">Previous sample bits</param>
 <param name="cur">Current sample bits</param>
 <param name="qs">3 registers: x=n qubits, g=n-1 qubits,, c=2 qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.ANDAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 AND' gate: High level QuAM gate
 </summary>
 <param name="cur">Current sample bits</param>
 <param name="qs">3 registers: x=n qubits, g=n-1 qubits,, c=2 qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.AND(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 AND gate: High level QuAM gate
 </summary>
 <param name="cur">Current sample bits</param>
 <param name="qs">3 registers: x=n qubits, g=n-1 qubits,, c=2 qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.FLIP(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 FLIP gate: High level QuAM gate
 </summary>
 <param name="prv">Previous pattern (n bits long)</param>
 <param name="cur">Current pattern (n bits long)</param>
 <param name="qs">3 registers: x=n qubits, g=n-1 qubits,, c=2 qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.CCNOT11(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Toffoli gate when |11> on first two
 </summary>
 <param name="qs"> Use first three qubits for gate</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.CCNOT10(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Toffoli gate when |10> on first two
 </summary>
 <param name="qs"> Use first three qubits for gate</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.CCNOT01(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Toffoli gate when |01> on first two
 </summary>
 <param name="qs"> Use first three qubits for gate</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.CCNOT00(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Toffoli gate when |00> on first two
 </summary>
 <param name="qs"> Use first three qubits for gate</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.CNOT1(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled NOT gate with 1 control
 </summary>
 <param name="qs"> Use first two qubits for gate</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.CNOT0(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled NOT gate with 0 control
 </summary>
 <param name="qs"> Use first two qubits for gate</param>
</member>
<member name="M:Microsoft.Research.Liquid.QuAMGates.SAMP(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Samp gate: 2 Qubit operator to define a sample
 </summary>
 <param name="p">Sample index (>= 1)</param>
 <param name="qs">Operate on first 2 qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.BinRot(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Do the binary rotation
 </summary>
 <param name="pwr">Power of denominator of rotation</param>
 <param name="qs">Anc + PE qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.Recip(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 For now eigen invert is just a qubit reversal
 </summary>
 <param name="qs">Eigenvalues to invert</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.QFT(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Do QFT (bits are reversed on exit)
 </summary>
 <param name="qsPE">PE qubits, 0=LSB</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.QFTAdj(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Do inverse QFT (bits are reversed on exit)
 </summary>
 <param name="qsPE">PE qubits, 0=MSB</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.PEkickAdj(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Run inverse phase kick-back on multiple phase qubits
 </summary>
 <param name="cUa">Controlled by single phase qubit(=0) for 1 Trotter step</param>
 <param name="trotterN">Trotter# to use</param>
 <param name="qsPE">Phase qubits (0=MSB)</param>
 <param name="qsU">Unitary qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.PEkick(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Run phase kick-back on multiple phase qubits
 </summary>
 <param name="cUa">Controlled by single phase qubit(=0) for 1 Trotter step</param>
 <param name="trotterN">Trotter# to use</param>
 <param name="qsPE">Phase qubits (0=MSB)</param>
 <param name="qsU">Unitary qubits</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CRAdj(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Inverse Controlled rotation gate
 </summary>
 <param name="k">Rotation by 2^k</param>
 <param name="qs">Qubits ([0]=Control [1]=rotated)</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CR(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 Controlled rotation gate
 </summary>
 <param name="k">Rotation by 2^k</param>
 <param name="qs">Qubits ([0]=Control [1]=rotated)</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.SimpSq(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 SimpSq: Simple squaring circuit
 </summary>
 <param name="rslt">Classical function called with bit values</param>
 <param name="theta1">rotate on first qubit</param>
 <param name="theta2">rotate on second qubit </param>
 <param name="qs">Operate on first 3 qubits </param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CCiX(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CCiX gate: Double controlled iX (used for squaring circuit)
 </summary>
 <param name="qs">Operate on first 3 qubits </param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.IiX(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 IiX gate: I+iX (used for squaring circuit)
 </summary>
 <param name="qs">Operate on first qubit </param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.iX(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 iX gate: iX (used for squaring circuit)
 </summary>
 <param name="qs">Operate on first qubit </param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CII(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CII gate: Controlled II on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CZZ(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CZZ gate: Controlled ZZ on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CXZ(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CXZ gate: Controlled XZ on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CYYAdj(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CYY' gate: Controlled YY on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CYY(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CYY gate: Controlled YY on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CXX(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CXX gate: Controlled XX on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.QLSA.CXI(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
 <summary>
 CXI gate: Controlled XI on consecutive wires (used for Nathan example)
 </summary>
 <param name="theta">Strength of coupling</param>
 <param name="qs">Operate on first 2 qubits after PE</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__QWalk(System.String)">
 <summary>
 Demonstrates the Quantum PageRank algorithm from
 <see href="http://arxiv.org/abs/1112.2079">Paparo and Martin-Delgado</see>.
 See the Users Manual for more information.
 </summary>
 <param name="which">The web graph to use. There are three built-in graphs:
 tiny, tree, and graph. Alternatively, the path to a .graph file may be provided.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__QuAM">
 <summary>
 Demonstrates the Quantum Associative Memory algorithm from
 <see href="http://arxiv.org/abs/quant-ph/9807053">Ventura and Martinez</see>.
 See the Users Manual for more information.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__QLSA">
 <summary>
 Demonstrates the Quantum Linear Algebra algorithm from 
 <see href="http://arxiv.org/abs/0811.3171">Harrow, Hassidim, and Lloyd</see>.
 See the Users Manual for more information.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__QFTbench">
 <summary>
 Benchmarks the Quantum Fourier Transform at the heart of the Shor algorithm.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__JointCNOT">
 <summary>
 Demonstrates and tests various ways of implementing CNOT from joint measurements
 and single-qubit Clifford gates.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__ChemFull(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
 <summary>
 Runs a quantum chemistry simulation.
 See the Users Manual for more information.
 </summary>
 <param name="mol">The name of the molecule to simulate.
 Entering an empty string, "", will display the list of available molecules.</param>
 <param name="test">The test number to run, from the .dat file.</param>
 <param name="opts">A string of any options you want to set.
 See the Users Manual for more information.</param>
 <param name="trot">The Trotter parameter; that is, number of Trotter steps per time step.</param>
 <param name="bits">The number of bits of accuracy desired in the phase estimation.</param>
 <param name="order">The order of Trotter approximation to use, 1 or 2.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Chem(System.String)">
 <summary>
 Runs a simple quantum chemistry simulation.
 This is the same as the 
 <see cref="">__ChemFull</see> sample,
 with common values for the detailed parameters: test 0, 32 Trotter steps, first-order Trotter,
 28 bits of accuracy, and no additional options.
 See the Users Manual for more information.
 </summary>
 <param name="mol">The name of the molecule to simulate.
 Entering an empty string, "", will display the list of available molecules.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Kraus(System.Int32,System.Double,System.Double,System.Boolean)">
 <summary>
 Show how to add noise to Teleport with Kraus operators
 </summary>
 <param name="nRuns">How many runs to gather statistics over</param>
 <param name="probAD">Probability of Amplitude Damping on any single qubit</param>
 <param name="probDP">Probability of Depolarizing noise on any single qubit</param>
 <param name="verbose">Output detailed stats and drawings</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__NoiseAmp">
 <summary>
 Demonstrates a complex noise model.
 See the Users Manual for more information.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Noise1(System.Int32,System.Int32,System.Double)">
 <summary>
 Demonstrates the use of a complex noise model with error correction.
 See the Users Manual for more information.
 </summary>
 <param name="depth">The number of idle gates to include in the circuit.</param>
 <param name="iters">The number of executions to run, for statistical purposes.</param>
 <param name="prob">The probability of an error occurring.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__EIGS">
 <summary>
 Validates that LAPACK is properly installed.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__EntEnt">
 <summary>
 Demonstrates a couple of simple entanglement entropy calculations.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__QECC">
 <summary>
 Demonstrates some examples of error correction and stabilizer simulation.
 See the Users Manual for details.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Steane7">
 <summary>
 Validates that the Steane 7 code is correct.
 See <see cref="M:Microsoft.Research.Liquid.Steane7.Test1">Steane7.Test1</see> for more details.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__TSP(System.Int32)">
 <summary>
 Solves the traveling salesman problem.
 </summary>
 <param name="nCities">The number of cities to include in the map, from 5 to 8.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Ramsey33">
 <summary>
 Solves for the (3,3) Ramsey number.
 See <see href="http://arxiv.org/abs/1201.1842">this paper</see> for details.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__SG">
 <summary>
 Simulates a spin glass using a first-quantized Hamiltonian.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Ferro(System.Boolean,System.Boolean)">
 <summary>
 Simulates a ferromagnetic chain using a first-quantized Hamiltonian.
 </summary>
 <param name="full">Whether to run all chain variations (isolated, ferromagnetic,
 anti-ferromagnetic, freeze up, freese down, and freeze up/down) or just the last 
 variation, freeze up/down.</param>
 <param name="runonce">For each variation, whether to run the circuit once and then
 do "virtual sampling" from the state vector, or to run the circuit and perform
 full simulated measurements each time.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Correct">
 <summary>
 Test various permutations for correctness using teleport
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Shor(System.Int32,System.Boolean)">
 <summary>
 Runs the classic Shor factoring algorithm.
 </summary>
 <param name="N">The number to factor.</param>
 <param name="doCirc">Whether or not to optimize the circuit.</param>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Big">
 <summary>
 Runs an entanglement test for state vectors from 16 to 22 qubits in size.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Entangles">
 <summary>
 Runs 100 entanglement tests on 16 qubits to show the statistics on the bits measured. 
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Entangle2(System.Int32)">
 <summary>
 Runs a simple gate sequence that entangles all the qubits in the state vector.
 The sequence is run three different ways to demonstrate the difference in timings.
 </summary>
 <param name="entSiz">The number of qubits desired in the state vector.</param>
 <remarks>
 This test executes the same gate sequence in three different ways:
 <ul>
 <li>As a simple sequence of gates. This is essentially the same as the 
 <see cref="M:Microsoft.Research.Liquid.Tests.__Entangle1(System.Int32)">__Entangle1</see> sample.</li>
 <li>As a compiled circuit.</li>
 <li>As a compiled circuit that has been optimized by calling 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">GrowGates</see>.</li>
 </ul>
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Entangle1(System.Int32)">
 <summary>
 Runs a simple gate sequence that entangles all the qubits in the state vector.
 </summary>
 <param name="entSiz">The number of qubits desired in the state vector.</param>
 <remarks>
 This sample displays detailed timing and memory usage information,
 and so allows you to see how Liquid scales as the state vector size grows.
 </remarks>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.entangleRun(System.String,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Circuit})">
<summary>
 Run entangle (size loops)
</summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__Teleport">
 <summary>
 Renders and runs the classic quantum teleportation algorithm.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.__EPR">
 <summary>
 Renders a small EPR circuit that entangles two qubits.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.Tests.RenderTest(System.String,Microsoft.Research.Liquid.Circuit,Microsoft.Research.Liquid.Ket)">
 <summary>
 Renders and dumps test circuits in a variety of formats and detail levels.
 </summary>
 <param name="name">The base name for the output files.</param>
 <param name="circ">The Circuit to render.</param>
 <param name="ket">The state vector for the circuit.</param>
 <remarks>
 Three versions of the circuit will be dumped to the log file:
 <ul>
 <li>The base circuit.</li>
 <li>The circuit aggressively folded to maximize parallelism.</li>
 <li>The circuit with gates grown to a maximum of 11 inputs, and then folded.</li>
 </ul>
 Four pairs of graphics files will be created.
 For each version, both an SVG version, with a .htm extension, 
 and a Tik-Z version, with a .tex, will be created.
 <ul>
 <li>The base circuit.</li>
 <li>The circuit normally folded to use "easy" parallelism.</li>
 <li>The circuit aggressively folded to maximize parallelism.</li>
 <li>The circuit with gates grown to a maximum of 11 inputs, and then folded.</li>
 </ul>
 </remarks>
</member>
<member name="T:Microsoft.Research.Liquid.Tests">
 <summary>
 A collection of sample Liquid simulations and tests,
 plus some utility routines to make it easier to write new samples.
 </summary>
</member>
<member name="M:Microsoft.Research.Liquid.App.RunLiquid">
 <summary>
 The main routine for running Liquid.
 This function gets the command-line parameters from the environment,
 parses them, and executes the requested Liquid method.
 </summary>
 <returns>0 if execution succeeded, or 1 if an error occured.</returns>
</member>
<member name="T:Microsoft.Research.Liquid.App">
 <summary>
 Utilities for executing the Liquid application.
 </summary>
</member>
</members>
</doc>
