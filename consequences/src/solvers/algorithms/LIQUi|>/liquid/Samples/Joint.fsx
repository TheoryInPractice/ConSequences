// Copyright (c) 2015,2016 Microsoft Corporation

#if INTERACTIVE
#r @"..\bin\Liquid1.dll"                 
#else
namespace Microsoft.Research.Liquid // Tell the compiler our namespace
#endif

open System                         // Open any support libraries
open System.Text

open Microsoft.Research.Liquid      // Get necessary Liquid libraries
open Util                           // General utilites
open Operations                     // Basic gates and operations

module Script =                     // The script module allows for incremental loading

    /// <summary>
    /// Format a state vector for output (only does 3 qubits)
    /// </summary>
    /// <param name="k">Ket vector</param>
    /// <param name="doMag">Do we want magnitude instead of complex values</param>
    let fmtKet (k:Ket) (doMag:bool) =
        let sb  = StringBuilder()
        let v   = k.Single()
        for adr in 0UL..v.Length-1UL do
            let itm   = v.[adr]
            if itm.MCC > 1.0e-6 then
                let b0  = if adr &&& 0x4UL = 0UL then 0 else 1
                let b1  = if adr &&& 0x2UL = 0UL then 0 else 1
                let b2  = if adr &&& 0x1UL = 0UL then 0 else 1
                if doMag then sprintf "|%d%d%d>=%3g" b0 b1 b2 itm.MCC |> sb.Append |> ignore
                else sprintf "|%d%d%d>=%O" b0 b1 b2 itm |> sb.Append |> ignore
        sb.ToString()

    /// <summary>
    /// Get a symbol from the symbol table (generated by a joint measurement)
    /// </summary>
    /// <param name="ket">Ket vector that hold the symbol table</param>
    /// <param name="nam">Name of the symbol</param>
    let sym (ket:Ket) (nam:string)    = ket.Symbol nam

    /// <summary>
    /// Joint Measurement CNOT example from Alan Geller
    /// </summary>
    /// <param name="qs">Q0=Control Q1=Taret Q2=Ancilla</param>
    let opAlan (qs:Qubits) =
        let k       = qs.Head.Ket
        let c,t,a   = qs.[0],qs.[1],qs.[2]

        H [a]
        JMz "p1" [c;a]  // Joint measure in the Z basis and call it "p1"
        
        H [a]
        H [t]
        JMz "p2" [a;t]
        H [a]
        H [t]
        JMz "p3" [a]

        // Perform parity contol gates based on Joint Measurements
        PC "p2" (fun qs -> sym k "p2" = 1) Z [c]
        PC "p1<>p3" (fun qs -> sym k "p1" <> sym k "p3") X [t]
        PC "p3" (fun qs -> sym k "p3" = 1) X [a]

    [<LQD>]
    let Joint() =
        logOpen "Liquid.log" false

        let k       = Ket(3)
        let qs      = k.Qubits
        let nam     = "Alan's CNOT"
        let circ    = Circuit.Compile opAlan qs
        circ.RenderHT("Joint",9,100.,80.)
        circ.Fold().RenderHT("JointF",9,100.,80.)
        showLog "Dump of: %s" nam
        circ.Dump()
        for inp0 in 0..1 do
            for inp1 in 0..1 do
                if inp0 = 0 && inp1 = 0 then
                    show "==== INP: %d%d %12s  => %s => %-26s [%s]" inp0 inp1 "|CTA>inp" "P123 " "|CTA>out" nam
                else show "---- INP: %d%d" inp0 inp1
                for inp2 in 0..2 do
                    let rec doTest iter prv =
                        let qs  = k.Reset(3)
                        if inp0 = 1 then qs.[0].StateSet(One)
                        if inp1 = 1 then qs.[1].StateSet(One)
                        let anc = 
                            match inp2 with
                            | 1    -> qs.[2].StateSet(One); "|1>"
                            | 2    -> H !!(qs,2); "|+>"
                            | _    -> "|0>"
                    
                        let inp = fmtKet k true
                        opAlan qs
                        let out = fmtKet k true
                    
                        let p1  = k.Symbol "p1"
                        let p2  = k.Symbol "p2"
                        let p3  = k.Symbol "p3"

                        if iter = 0 then doTest 1 out
                        else
                            if out <> prv then
                                show "%26s -> (%d%d%d) -> %-26s Anc=%s NON-DETERMINISTIC" inp p1 p2 p3 prv anc
                            if iter < 3 then doTest (iter+1) out
                            else show "%26s => (%d%d%d) => %-26s Anc=%s" inp p1 p2 p3 out anc
                    doTest 0 ""


#if INTERACTIVE
do 
    Script.Joint()        // If interactive, then run the routine automatically
#endif

